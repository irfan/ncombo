var fork = require('child_process').fork;
var EventEmitter = require('events').EventEmitter;
var net = require('net');
var formatter = require('./formatter');

var DEFAULT_PORT = 9435;
var HOST = '127.0.0.1';

var Server = function(port, secretKey) {
	var self = this;
	
	var args;
	if(secretKey) {
		args = [port, secretKey];
	} else {
		args = [port];
	}
	
	self._server = fork(__dirname + '/server.js', args);
	
	self._server.on('message', function(value) {
		if(value.event == 'listening') {
			self.emit('ready');
		}
	});
}

Server.prototype.__proto__ = EventEmitter.prototype;

module.exports.createServer = function(port, secretKey) {
	if(!port) {
		port = DEFAULT_PORT;
	}
	return new Server(port, secretKey);
}

var Client = function(port, host, secretKey) {
	var self = this;
	secretKey = secretKey || null;
	self._chanelWatchers = {};
	self._commandMap = {};
	
	self._socket = new net.Socket();
	
	self._curID = 1;
	self.MAX_ID = Math.pow(2, 53) - 2;
	
	self._genID = function() {
		self._curID = (self._curID + 1) % self.MAX_ID;
		return 'n' + self._curID;
	}
	
	self._broadcast = function(event, value) {
		if(self._chanelWatchers.hasOwnProperty(event)) {
			var watchers = self._chanelWatchers[event];
			var i;
			for(i in watchers) {
				watchers[i](value);
			}
		}
	}
	
	self._socket.connect(port, host, function() {		
		if(secretKey) {
			var command = {
				action: 'init',
				secretKey: secretKey
			}
			
			self._exec(command, function(data) {
				self.emit('ready');
			});
		} else {
			self.emit('ready');
		}		
	});
	
	self._socket.on('data', function(responseBuffer) {
		var responses = formatter.parse(responseBuffer);
		var i, response, id, action;
		for(i in responses) {
			response = responses[i];
			id = response.id;
			if(response.type == 'response') {
				if(response.error) {
					console.log('   nData Error - ' + response.error);
					self.emit('fail', response.error);
				} else if(self._commandMap.hasOwnProperty(id)) {
					action = response.action;
					 
					if(response.value) {
						self._commandMap[id].callback(response.value);
					} else if(action == 'subscribe' || action == 'unsubscribe') {
						if(response.success) {
							self._commandMap[id].callback(response.event);
						}
					} else if(self._commandMap[id].callback) {
						self._commandMap[id].callback();
					}
					
					delete self._commandMap[id];
				}
			} else if(response.type == 'event') {
				self._broadcast(response.event, response.value);
			}
		}
	});
	
	self._exec = function(command, callback) {
		command.id = self._genID();
		
		if(callback) {
			self._commandMap[command.id] = {callback: callback, command: command};
		}
		
		self._socket.write(formatter.stringify(command));
	}
	
	self._subscribe = function(event) {
		var command = {
			action: 'subscribe',
			event: event	
		}
		var callback = function() {
			self.emit('subscribe');
		}
		
		self._exec(command, callback);
	}
	
	self._isEmpty = function(object) {
		var i;
		var empty = true;
		for(i in object) {
			empty = false;
			break;
		}
		return empty;
	}
	
	self._unsubscribe = function(event) {
		var command = {
			action: 'unsubscribe',
			event: event	
		}
		var callback = function() {
			self.emit('unsubscribe');
		}
		
		self._exec(command, callback);
	}
	
	self.watch = function(event, callback) {
		if(!self._chanelWatchers[event]) {
			self._chanelWatchers[event] = [];
		}
		self._chanelWatchers[event].push(callback);
		self._subscribe(event);
	}
	
	self.watchOnce = function(event, callback) {
		if(!self._chanelWatchers[event]) {
			self._chanelWatchers[event] = [];
			self._chanelWatchers[event].push(callback);
			self._subscribe(event);
		}
	}
	
	self.unwatch = function(event, callback) {
		if(event) {
			if(self._chanelWatchers.hasOwnProperty(event)) {
				if(callback) {
					var newWatchers = [];
					var watchers = self._chanelWatchers[event];
					var i;
					for(i in watchers) {
						if(watchers[i] != callback) {
							newWatchers.push(watchers[i]);
						}
					}
					self._chanelWatchers[event] = newWatchers;
				} else {
					delete self._chanelWatchers[event];
				}
			}
			if(self._isEmpty(self._chanelWatchers)) {
				self._unsubscribe(event);
			}
		} else {
			self._chanelWatchers = {};
			self._unsubscribe();
		}
	}
	
	self.broadcast = function(event, value) {
		var command = {
			action: 'broadcast',
			event: event,
			value: value	
		}
		
		self._exec(command);
	}
	
	self.set = function(key, value, callback) {
		var command = {
			action: 'set',
			key: key,
			value: value
		}
		self._exec(command, callback);
	}
	
	self.add = function(key, value, callback) {
		var command = {
			action: 'add',
			key: key,
			value: value
		}
		self._exec(command, callback);
	}
	
	self.remove = function(key, callback) {
		var command = {
			action: 'remove',
			key: key
		}
		self._exec(command, callback);
	}
	
	self.removeAll = function(callback) {
		var command = {
			action: 'removeAll'
		}
		self._exec(command, callback);
	}
	
	self.pop = function(key, callback) {
		var command = {
			action: 'pop',
			key: key
		}
		self._exec(command, callback);
	}

	self.get = function(key, callback) {
		var command = {
			action: 'get',
			key: key	
		}
		self._exec(command, callback);
	}
	
	self.getAll = function(callback) {
		var command = {
			action: 'getAll'
		}
		self._exec(command, callback);
	}
}

Client.prototype.__proto__ = EventEmitter.prototype;

module.exports.createClient = function(port, secretKey) {
	if(!port) {
		port = DEFAULT_PORT;
	}
	
	return new Client(port, HOST, secretKey);
}
