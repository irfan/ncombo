var io = require('socket.io/node_modules/socket.io-client/lib/socket.io-client'),
	path = require('path');

var WebServiceClient = function(host, port, secure, wsEndpoint) {
	var self = this;
	
	if(!wsEndpoint) {
		wsEndpoint = '/ws';
	}
	
	var wsURL = (secure ? 'https://' : 'http://') + host + ":" + port + wsEndpoint;
	
	self._callTracker = {};
	self._wsSocket = io.connect(wsURL);
	
	self._mainNamespace = new NS('__main', self._wsSocket);
	self._namespaces = {'__main': self._mainNamespace};
	
	self._callReturn = function(data) {
		var cid = data.cid;
		if(self._callTracker[cid]) {
			if(!data.noValue) {
				var finish = data.close ? true : false;
				if(!data.error) {
					if(self._callTracker[cid].success) {
						self._callTracker[cid].success(data.value, finish);
					}
				} else if(self._callTracker[cid].error) {
					self._callTracker[cid].error(data.value, finish);
				}
			}
			if(data.close) {
				delete self._callTracker[cid];
			}
			if(data.error) {
				throw data.value;
			}
		}
	}
	
	self._eventReceived = function(data) {
		self.ns(data.namespace)._triggerWatchers(data.event, data.data);
	}
	
	self._wsSocket.on('return', self._callReturn);
	self._wsSocket.on('event', self._eventReceived);
	
	self.acall = function() {
		var serverInterface = arguments[0];
		var method = arguments[1];
		var data = null
		var resultHandler = null;
		var errorHandler = null;
		
		if(arguments[2] && (arguments[2] instanceof Function || (arguments[2] instanceof Object && arguments[2].success && arguments[2].success instanceof Function))) {
			resultHandler = arguments[2];
			if(arguments.length > 3) {
				errorHandler = arguments[3];
			}
		} else {
			data = arguments[2];
			resultHandler = arguments[3];
			if(arguments.length > 4) {
				errorHandler = arguments[4];
			}
		}
		
		var handler = null;
		
		if(resultHandler) {
			if(resultHandler.success) {
				handler = resultHandler;
			} else {
				handler = {success: resultHandler};
				if(errorHandler) {
					handler.error = errorHandler;
				}
			}
		}
		
		var cid = WebService.genID();
		var request = {
			si: serverInterface,
			method: method,
			data: data,
			cid: cid
		};
		
		self._callTracker[cid] = handler;
		
		self._wsSocket.emit('sic', request);
	}
	
	self.ns = function(namespace) {
		if(!$n._namespaces[namespace]) {
			$n._namespaces[namespace] = new $n.NS(namespace, $n._wsSocket);
		}
		return $n._namespaces[namespace];
	}
	
	self.watch = function() {
		$n._mainNamespace.watch.apply(null, arguments);
	}
	
	self.unwatch = function() {
		$n._mainNamespace.unwatch.apply(null, arguments);
	}
	
	self.isWatching = function() {
		$n._mainNamespace.isWatching.apply(null, arguments);
	}
}

var NS = function(namespace, wsSocket) {
	var self = this;
	self._namespace = namespace;
	self._wsSocket = wsSocket;
	self._serverWatchMap = {};
	
	self.watch = function(event, handler) {
		if(!event || !handler) {
			throw "Exception: One or more required parameters were undefined";
		}
		
		if(!self._serverWatchMap.hasOwnProperty(event)) {
			self._serverWatchMap[event] = [];
		}
		
		self._serverWatchMap[event].push(handler);
		
		var request = {
			ns: self._namespace,
			event: event
		};
		
		self._wsSocket.emit('watch', request);
	}
	
	self.unwatch = function(event, handler) {
		var i, j;
		var unwatchRequests = [];
		
		if(!event) {
			for(j in self._serverWatchMap) {
				unwatchRequests.push({ns: self._namespace, event: j});
			}
			if(unwatchRequests.length > 0) {
				self._wsSocket.emit('unwatch', unwatchRequests);
			}
		} else if(!handler) {
			if(self._serverWatchMap[event]) {
				unwatchRequests.push({ns: self._namespace, event: event});
				delete self._serverWatchMap[event];
				if(unwatchRequests.length > 0) {
					self._wsSocket.emit('unwatch', unwatchRequests);
				}
			}
		} else {
			if(self._serverWatchMap[event]) {
				self._serverWatchMap[event] = $.grep(self._serverWatchMap[event], function(element, index) {
					if(element == handler) {
						unwatchRequests.push({ns: self._namespace, event: event});
						return false;
					}
					return true;
				});
				if(unwatchRequests.length > 0) {
					self._wsSocket.emit('unwatch', unwatchRequests);
				}
			}
		}
	}
	
	self._getWatcher = function(event, handler) {
		if(!event || !handler) {
			throw "Exception: One or more required parameters were undefined";
		}
		
		if(self._serverWatchMap[event]) {
			var watchers = self._serverWatchMap[event];
			var len = watchers.length;
			var i;
			for(i=0; i<len; i++) {
				if(watchers[i] == handler) {
					return watchers[i];
				}
			}
		}
		return null;
	}
	
	self.isWatching = function(event, handler) {
		return self._getWatcher(event, handler) ? true : false;
	}
	
	self._triggerWatchers = function(event, data) {
		if(self._serverWatchMap && self._serverWatchMap[event]) {
			var watchers = self._serverWatchMap[event];
			var len = watchers.length;
			var i;
			for(i=0; i<len; i++) {
				watchers[i].call(null, data);
			}
		}
	}
}

var WebService = new (function() {
	var self = this;
	self.MAX_ID = Math.pow(2, 53) - 2;
	self._callCount = 0;
	
	self.genID = function() {
		self._callCount++;
		self._callCount = self._callCount % self.MAX_ID;
		return self._callCount;
	}
	
	self.getClient = function(host, port, secure, wsEndpoint) {
		return new WebServiceClient(host, port, secure, wsEndpoint);
	}
})();

module.exports = WebService;