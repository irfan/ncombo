var io = require('socket.io-client'),
	path = require('path'),
	EventEmitter = require('events').EventEmitter;

var WebServiceClient = function(host, port, secure, wsEndpoint) {
	var self = this;
	self._connected = false;
	self._connecting = false;
	self._wsSocket = null;
	self._mainNamespace = null;
	self._namespaces = {};
	self._callTracker = {};
	self._callback = null;
	
	self._timeout = 10000;
	
	self.host = host;
	self.port = port;
	self.secure = secure;
	self.wsEndpoint = wsEndpoint;
	
	self.MAX_ID = Math.pow(2, 53) - 2;
	self._curID = 1;
	self._genID = function() {
		self._curID++;
		self._curID = self._curID % self.MAX_ID;
		return 'r' + self._curID;
	}
	
	self.setTimeout = function(timeout) {
		self._timeout = timeout;
	}
	
	self.asClientURL = function(clientDesc) {
		return (clientDesc.secure ? 'https://' : 'http://') + clientDesc.host + ":" + clientDesc.port + clientDesc.wsEndpoint;
	}
	
	self._wsURL = self.asClientURL({host: host, port: port, secure: secure, wsEndpoint: wsEndpoint});
	
	self.getURL = function() {
		return self._wsURL;
	}
	
	self._disconnect = function() {
		self._wsSocket.removeAllListeners('disconnect');
		self._callTracker = {};
		self.unwatchAll();
		self._connected = false;
		self._connecting = false;
		self.emit('disconnect');
	}
	
	self._connect = function(callback) {
		self._connecting = true;
		self._callTracker = {};
		
		self._wsSocket = io.connect(self._wsURL);
		
		var connected = self._wsSocket.socket.connected;
		
		var init = function() {
			self._wsSocket.removeAllListeners('return');
			self._wsSocket.removeAllListeners('event');
			self._wsSocket.on('return', self._callReturn);
			self._wsSocket.on('event', self._eventReceived);
			
			self._mainNamespace = self.ns('__main');
			self._namespaces = {'__main': self._mainNamespace};
		
			self._wsSocket.emit('init');
			self._connecting = false;
			self._connected = true;
			if(callback) {
				callback();
			}
			self.emit('connection');
		}
		if(connected) {
			init();
		} else {
			self._wsSocket.removeAllListeners('connect');
			self._wsSocket.on('connect', init);
		}
		
		self._wsSocket.removeAllListeners('disconnect');
		self._wsSocket.on('disconnect', self._disconnect);
	}
	
	self.connect = function(callback) {	
		var connectTimeout = setTimeout(function() {
			if(callback) {
				callback('Failed to connect to web service');
			}
		}, self._timeout);
		
		var cb = function(err) {
			clearTimeout(connectTimeout);
			if(callback) {
				callback(err);
			}
		}
		
		if(self._connected) {
			cb();
		} else if(self._connecting) {
			self.on('connection', function() {
				self.removeAllListeners('connection');
				cb();
			});
		} else if(self._wsSocket) {
			self._wsSocket.removeAllListeners('disconnect');
			
			if(self._wsSocket.socket.connected) {
				self._wsSocket.on('disconnect', function() {
					self._disconnect();
					self._connect(cb);
				});
				self.disconnect();
			} else {
				self._connect(cb);
			}
		} else {
			self._connect(cb);
		}
	}
	
	self.connect();
	
	self._callReturn = function(data) {
		var cid = data.cid;
		if(self._callTracker[cid]) {
			if(!data.noValue) {
				var finish = data.close ? true : false;
				if(self._callTracker[cid]) {
					self._callTracker[cid](data.error, data.value, finish);
				}
			}
			if(data.close) {
				delete self._callTracker[cid];
			}
		}
	}
	
	self.trackRequest = function(cid, callback) {
		self._callTracker[cid] = callback;
	}
	
	self._eventReceived = function(event) {
		self.ns(event.ns)._triggerWatchers(event.event, event.data);
	}
	
	self.isConnected = function() {
		return self._connected;
	}
	
	self.disconnect = function() {
		self._wsSocket.disconnect();
	}
	
	self.exec = function() {
		var serverInterface = arguments[0];
		var method = arguments[1];
		var data = null;
		var cid = self._genID();
		
		if(arguments[3]) {
			data = arguments[2];
			var callback = arguments[3];
			self._callTracker[cid] = callback;
		} else if(arguments[2]) {
			if(arguments[2] instanceof Function) {
				var callback = arguments[2];
				self._callTracker[cid] = callback;
			} else {
				data = arguments[2];
			}
		}
		
		var request = {
			remote: true,
			host: host,
			port: port,
			secure: secure,
			wsEndpoint: wsEndpoint,
			si: serverInterface,
			method: method,
			data: data,
			cid: cid
		};
		
		self.connect(function(err) {
			if(err) {
				if(self._callTracker[cid]) {
					self._callTracker[cid](err, null, true);
					delete self._callTracker[cid];
				}
			} else {
				self._wsSocket.emit('localCall', request);
			}
		});
	}
	
	self.ns = function(namespace) {
		if(!self._namespaces[namespace]) {
			self._namespaces[namespace] = new NS(namespace, self._wsSocket, self);
		}
		return self._namespaces[namespace];
	}
	
	self.watch = function() {
		var args = arguments;
		self.connect(function(err) {
			if(err) {
				if(args[2] instanceof Function) {
					args[2](err);
				}
			} else {
				self._mainNamespace.watch.apply(null, args);
			}
		});
	}
	
	self.unwatch = function() {
		var args = arguments;
		self.connect(function(err) {
			if(err) {
				if(args[2] instanceof Function) {
					args[2](err);
				}
			} else {
				self._mainNamespace.unwatch.apply(null, args);
			}
		});
	}
	
	self.unwatchAll = function(ackCallback) {
		self.connect(function(err) {
			if(err) {
				if(ackCallback) {
					ackCallback(err);
				}
			} else {
				var i;
				var nsCount = 0;
				var nsSuccess = 0;
				var emittedFail = false;
				for(i in self._namespaces) {
					nsCount++;
				}
				if(nsCount) {
					for(i in self._namespaces) {
						self._namespaces[i].unwatch(null, null, function(err) {
							if(err) {
								if(!emittedFail) {
									if(ackCallback) {
										ackCallback('Failed to unwatch all events');
									}
									emittedFail = true;
								}
							} else {
								if(++nsSuccess >= nsCount) {
									if(ackCallback) {
										ackCallback();
									}
								}
							}
						});
					}
				} else {
					if(ackCallback) {
						ackCallback();
					}
				}
			}
		});
	}
	
	self.isWatching = function() {
		self._mainNamespace.isWatching.apply(null, arguments);
	}
	
	self.hasWatcher = function() {
		self._mainNamespace.hasWatcher.apply(null, arguments);
	}
}

WebServiceClient.prototype.__proto__ = EventEmitter.prototype;

var NS = function(namespace, wsSocket, wsClient) {
	var self = this;
	self._namespace = namespace;
	self._wsSocket = wsSocket;
	self._wsClient = wsClient;
	self._serverWatchMap = {};
	
	self.MAX_ID = Math.pow(2, 53) - 2;
	self._curID = 1;
	self._genID = function() {
		self._curID++;
		self._curID = self._curID % self.MAX_ID;
		return 'rn' + self._curID;
	}
	
	self.watch = function(event, handler, ackCallback) {
		if(!event || !handler) {
			throw new Error("   Exception: One or more required parameters were undefined");
		}
		
		self._wsClient.connect(function(err) {
			if(err) {
				if(ackCallback) {
					ackCallback(err);
				}
			} else {				
				if(!self._serverWatchMap.hasOwnProperty(event)) {
					self._serverWatchMap[event] = [];
				}
				self._serverWatchMap[event].push(handler);
				
				var ackHandler = function(err) {
					if(err) {
						delete self._serverWatchMap[event];
					}
					if(ackCallback) {
						ackCallback(err);
					}
				}
				
				if(self._serverWatchMap[event].length < 2) {
					var cid = self._genID();
					var request = {
						remote: true,
						host: self._wsClient.host,
						port: self._wsClient.port,
						secure: self._wsClient.secure,
						wsEndpoint: self._wsClient.wsEndpoint,
						ns: self._namespace,
						event: event,
						cid: cid
					};
					
					self._wsClient.trackRequest(cid, ackHandler);
					self._wsSocket.emit('watchLocal', request);
				} else {
					if(ackCallback) {
						ackCallback();
					}
				}
			}
		});
	}
	
	self.unwatch = function(event, handler, ackCallback) {
		self._wsClient.connect(function(err) {
			if(err) {
				if(ackCallback) {
					ackCallback(err);
				}
			} else {
				var i, j;
				var cid = self._genID();
				var unwatchRequest = {cid: cid, requests: []};
				
				if(!event) {
					for(j in self._serverWatchMap) {
						unwatchRequest.requests.push({
							remote: true,
							host: self._wsClient.host,
							port: self._wsClient.port,
							secure: self._wsClient.secure,
							wsEndpoint: self._wsClient.wsEndpoint,
							ns: self._namespace,
							event: j
						});
					}
					self._serverWatchMap = {};
					if(unwatchRequest.requests.length > 0) {
						self._wsClient.trackRequest(cid, ackCallback);
						self._wsSocket.emit('unwatchLocal', unwatchRequest);
					} else {
						if(ackCallback) {
							ackCallback();
						}
					}
				} else if(!handler) {
					if(self._serverWatchMap[event]) {
						unwatchRequest.requests.push({
							remote: true,
							host: self._wsClient.host,
							port: self._wsClient.port,
							secure: self._wsClient.secure,
							wsEndpoint: self._wsClient.wsEndpoint,
							ns: self._namespace,
							event: event
						});
						
						delete self._serverWatchMap[event];
						if(unwatchRequest.requests.length > 0) {
							self._wsClient.trackRequest(cid, ackCallback);
							self._wsSocket.emit('unwatchLocal', unwatchRequest);
						} else {
							if(ackCallback) {
								ackCallback();
							}
						}
					} else {
						if(ackCallback) {
							ackCallback();
						}
					}
				} else {
					if(self._serverWatchMap[event]) {
						var len = self._serverWatchMap[event].length;
						var newEventList = [];
						for(i=0; i<len; i++) {
							if(self._serverWatchMap[event][i] == handler) {
								unwatchRequest.requests.push({
									remote: true,
									host: self._wsClient.host,
									port: self._wsClient.port,
									secure: self._wsClient.secure,
									wsEndpoint: self._wsClient.wsEndpoint,
									ns: self._namespace,
									event: event
								});
							} else {
								newEventList.push(self._serverWatchMap[event][i]);
							}
						}
						
						if(unwatchRequest.requests.length > 0) {
							if(newEventList < 1) {
								self._wsClient.trackRequest(cid, ackCallback);
								self._wsSocket.emit('unwatchLocal', unwatchRequest);
							} else {
								if(ackCallback) {
									ackCallback();
								}
							}
							self._serverWatchMap[event] = newEventList;
						} else {
							if(ackCallback) {
								ackCallback();
							}
						}
					} else {
						if(ackCallback) {
							ackCallback();
						}
					}
				}
			}
		});
	}
	
	self._getWatcher = function(event, handler) {
		if(!event || !handler) {
			throw "Exception: One or more required parameters were undefined";
		}
		if(self._serverWatchMap[event]) {
			var watchers = self._serverWatchMap[event];
			var len = watchers.length;
			var i;
			for(i=0; i<len; i++) {
				if(watchers[i] == handler) {
					return watchers[i];
				}
			}
		}
		return null;
	}
	
	self.hasWatcher = function(event) {
		return self._serverWatchMap.hasOwnProperty(event);
	}
	
	self.isWatching = function(event, handler) {
		return self._getWatcher(event, handler) ? true : false;
	}
	
	self._triggerWatchers = function(event, data) {
		if(self._serverWatchMap && self._serverWatchMap[event]) {
			var watchers = self._serverWatchMap[event];
			var len = watchers.length;
			var i;
			for(i=0; i<len; i++) {
				watchers[i].call(null, data);
			}
		}
	}
}

var WebService = function() {
	var self = this;
	self._webServiceMap = {};
	self._watchMap = {};
	
	self._releaseMode = false;
	self._timeout = 10000;
	
	self.setReleaseMode = function(bool) {
		self._releaseMode = bool;
	}
	
	self.setTimeout = function(timeout) {
		self._timeout = timeout;
	}
	
	self.exec = function(siReq) {
		var client = self.getClient(siReq.request.host, siReq.request.port, siReq.request.secure, siReq.request.wsEndpoint);
		var serverInterface = siReq.request.si;
		var method = siReq.request.method;
		var data = siReq.request.data;
		
		var callback = function(err, data, finish) {
			if(err) {
				if(finish) {
					siReq.collapse(err);
				} else {
					siReq.error(err);
				}
				console.log(err);
			} else {
				if(finish) {
					siReq.end(data);
				} else {
					siReq.send(data);
				}
			}
		}
		
		client.connect(function(err) {
			if(err) {
				callback(err, null, true);
			} else {
				client.exec(serverInterface, method, data, callback);
			}
		});
	}
	
	self.watch = function(siReq) {
		var request = siReq.request;
		var client = self.getClient(request.host, request.port, request.secure, request.wsEndpoint);
		var emittedFail = false;
		
		var eventData = {
			remote: true,
			host: request.host,
			port: request.port,
			secure: request.secure,
			wsEndpoint: request.wsEndpoint,
			ns: request.ns,
			event: request.event
		}
		
		var handler = function(data) {
			eventData.data = data;
			siReq.session.ns(request.ns).emitRaw(eventData);
		}
		
		if(!self._watchMap.hasOwnProperty(siReq.session.id)) {
			self._watchMap[siReq.session.id] = [];
		}
		self._watchMap[siReq.session.id].push({ns: request.ns, event: request.event, client: client, handler: handler});
		
		client.ns(request.ns).watch(request.event, handler, function(err) {
			if(err) {
				if(!emittedFail) {
					siReq.collapse(err);
					emittedFail = true;
				}
			} else {
				siReq.end();
			}
		});
	}
	
	self.unwatch = function(siReq) {
		var socket = siReq.socket;
		var requests = siReq.request.requests;
		var len = requests.length;
		var successCount = 0;
		var emittedFail = false;
		var i, client, request;
		for(i=0; i<len; i++) {
			request = requests[i];
			client = self.getClient(request.host, request.port, request.secure, request.wsEndpoint);
			
			if(socket) {
				if(self._watchMap.hasOwnProperty(socket.id)) {
					var watchers = [];
					var j, curWatcher;
					
					for(j in self._watchMap[socket.id]) {
						curWatcher = self._watchMap[socket.id][j];
						if(!(curWatcher.ns == request.ns && curWatcher.event == request.event)) {
							watchers.push(curWatcher);
						}
					}
					
					self._watchMap[socket.id] = watchers;
				}
			}
			
			client.ns(request.ns).unwatch(request.event, null, function(err) {
				if(err) {
					if(!emittedFail) {
						siReq.collapse(err);
						emittedFail = true;
					}
				} else {
					if(++successCount >= len) {
						siReq.end();
					}
				}
			});
		}
	}
	
	self.unwatchAll = function(socket, ackCallback) {
		var i, curWatcher;
		var successCount = 0;
		var failEmitted = false;
		
		var numReqs = 0;
		for(i in self._watchMap[socket.id]) {
			numReqs++;
		}
		for(i in self._watchMap[socket.id]) {
			curWatcher = self._watchMap[socket.id][i];
			curWatcher.client.ns(curWatcher.ns).unwatch(curWatcher.event, curWatcher.handler, function(err) {
				if(err) {
					if(!failEmitted) {
						if(ackCallback) {
							ackCallback();
						}
						failEmitted = true;
					}
				} else {
					if(++successCount >= numReqs) {
						if(ackCallback) {
							ackCallback(err);
						}
					}
				}
			});
		}
		self._watchMap[socket.id] = [];
	}
	
	self.getClient = function(host, port, secure, wsEndpoint) {
		if(!wsEndpoint) {
			wsEndpoint = '/ws';
		}
		
		var url = (secure ? 'https://' : 'http://') + host + ":" + port + wsEndpoint;
		if(!self._webServiceMap.hasOwnProperty(url)) {
			self._webServiceMap[url] = new WebServiceClient(host, port, secure, wsEndpoint);
			self._webServiceMap[url].setTimeout(self._timeout);
		}
		
		return self._webServiceMap[url];
	}
}

WebService.prototype.__proto__ = EventEmitter.prototype;

module.exports = new WebService();
