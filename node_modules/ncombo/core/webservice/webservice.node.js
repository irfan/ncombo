var io = require('socket.io-client'),
	path = require('path'),
	EventEmitter = require('events').EventEmitter;

var WebServiceClient = function(host, port, secure, wsEndpoint) {
	var self = this;
	self._connected = false;
	self._connecting = false;
	self._wsSocket = null;
	self._mainNamespace = null;
	self._namespaces = {};
	self._callTracker = {};
	self._callback = null;
	
	self.host = host;
	self.port = port;
	self.secure = secure;
	self.wsEndpoint = wsEndpoint;
	
	self.MAX_ID = Math.pow(2, 53) - 2;
	self._curID = 1;
	self._genID = function() {
		self._curID++;
		self._curID = self._curID % self.MAX_ID;
		return 'r' + self._curID;
	}
	
	self.asClientURL = function(clientDesc) {
		return (clientDesc.secure ? 'https://' : 'http://') + clientDesc.host + ":" + clientDesc.port + clientDesc.wsEndpoint;
	}
	
	self._wsURL = self.asClientURL({host: host, port: port, secure: secure, wsEndpoint: wsEndpoint});
	
	self.getURL = function() {
		return self._wsURL;
	}
	
	self._disconnect = function() {
		self._wsSocket.removeAllListeners('disconnect');
		self._callTracker = {};
		self.unwatchAll();
		self._connected = false;
		self._connecting = false;
		self.emit('disconnect');
	}
	
	self._connect = function(callback) {
		self._connecting = true;
		self._callTracker = {};
		
		self._wsSocket = io.connect(self._wsURL);
		
		var connected = self._wsSocket.socket.connected;
		
		var init = function() {
			self._wsSocket.removeAllListeners('return');
			self._wsSocket.removeAllListeners('event');
			self._wsSocket.on('return', self._callReturn);
			self._wsSocket.on('event', self._eventReceived);
			
			self._mainNamespace = new NS('__main', self._wsSocket, self);
			self._namespaces = {'__main': self._mainNamespace};
		
			self._wsSocket.emit('init');
			self._connecting = false;
			self._connected = true;
			if(callback) {
				callback();
			}
			self.emit('connection');
		}
		if(connected) {
			init();
		} else {
			self._wsSocket.removeAllListeners('connect');
			self._wsSocket.on('connect', init);
		}
		
		self._wsSocket.removeAllListeners('disconnect');
		self._wsSocket.on('disconnect', function() {
			self._disconnect();
		});
	}
	
	self.connect = function(callback) {
		if(self._connected) {
			if(callback) {
				callback();
			}
		} else if(self._connecting) {
			self.once('connection', function() {
				if(callback) {
					callback();
				}
			});
		} else if(self._wsSocket) {
			self._wsSocket.removeAllListeners('disconnect');
			
			if(self._wsSocket.socket.connected) {
				self._wsSocket.on('disconnect', function() {
					self._disconnect();
					self._connect(callback);
				});
				self.disconnect();
			} else {
				self._connect(callback);
			}
		} else {
			self._connect(callback);
		}
	}
	
	self.connect();
	
	self._callReturn = function(data) {
		var cid = data.cid;
		
		if(self._callTracker[cid]) {
			if(!data.noValue) {
				var finish = data.close ? true : false;
				if(!data.error) {
					if(self._callTracker[cid].success) {
						self._callTracker[cid].success(data.value, finish);
					}
				} else if(self._callTracker[cid].error) {
					self._callTracker[cid].error(data.value, finish);
				}
			}
			if(data.close) {
				delete self._callTracker[cid];
			}
			if(data.error) {
				throw data.value;
			}
		}
	}
	
	self._eventReceived = function(event) {
		self.ns(event.ns)._triggerWatchers(event.event, event.data);
	}
	
	self.isConnected = function() {
		return self._connected;
	}
	
	self.disconnect = function() {
		self._wsSocket.disconnect();
	}
	
	self.exec = function() {
		var serverInterface = arguments[0];
		var method = arguments[1];
		var data = null
		var resultHandler = null;
		var errorHandler = null;
		
		if(arguments[2] && (arguments[2] instanceof Function || (arguments[2] instanceof Object && arguments[2].success && arguments[2].success instanceof Function))) {
			resultHandler = arguments[2];
			if(arguments.length > 3) {
				errorHandler = arguments[3];
			}
		} else {
			data = arguments[2];
			resultHandler = arguments[3];
			if(arguments.length > 4) {
				errorHandler = arguments[4];
			}
		}
		
		var handler = null;
		
		if(resultHandler) {
			if(resultHandler.success) {
				handler = resultHandler;
			} else {
				handler = {success: resultHandler};
				if(errorHandler) {
					handler.error = errorHandler;
				}
			}
		}
		
		var cid = self._genID();
		var request = {
			remote: true,
			host: host,
			port: port,
			secure: secure,
			wsEndpoint: wsEndpoint,
			si: serverInterface,
			method: method,
			data: data,
			cid: cid
		};
		
		self._callTracker[cid] = handler;
		
		self._wsSocket.emit('localCall', request);
	}
	
	self.ns = function(namespace) {
		if(!self._namespaces[namespace]) {
			self._namespaces[namespace] = new NS(namespace, self._wsSocket, self);
		}
		return self._namespaces[namespace];
	}
	
	self.watch = function() {
		self._mainNamespace.watch.apply(null, arguments);
	}
	
	self.unwatch = function() {
		self._mainNamespace.unwatch.apply(null, arguments);
	}
	
	self.unwatchAll = function() {
		var i;
		for(i in self._namespaces) {
			self._namespaces[i].unwatch();
		}
	}
	
	self.isWatching = function() {
		self._mainNamespace.isWatching.apply(null, arguments);
	}
	
	self.hasWatcher = function() {
		self._mainNamespace.hasWatcher.apply(null, arguments);
	}
}

WebServiceClient.prototype.__proto__ = EventEmitter.prototype;

var NS = function(namespace, wsSocket, wsClient) {
	var self = this;
	self._namespace = namespace;
	self._wsSocket = wsSocket;
	self._wsClient = wsClient;
	self._serverWatchMap = {};
	
	self.watch = function(event, handler) {
		if(!event || !handler) {
			throw "Exception: One or more required parameters were undefined";
		}
		
		if(!self._serverWatchMap.hasOwnProperty(event)) {
			self._serverWatchMap[event] = [];
		}
		
		self._serverWatchMap[event].push(handler);
		
		if(self._serverWatchMap[event].length < 2) {
			var request = {
				remote: true,
				host: self._wsClient.host,
				port: self._wsClient.port,
				secure: self._wsClient.secure,
				wsEndpoint: self._wsClient.wsEndpoint,
				ns: self._namespace,
				event: event
			};
			
			self._wsSocket.emit('watchLocal', request);
		}
	}
	
	self.unwatch = function(event, handler) {
		var i, j;
		var unwatchRequests = [];
		
		if(!event) {
			for(j in self._serverWatchMap) {
				unwatchRequests.push({
					remote: true,
					host: self._wsClient.host,
					port: self._wsClient.port,
					secure: self._wsClient.secure,
					wsEndpoint: self._wsClient.wsEndpoint,
					ns: self._namespace,
					event: j
				});
			}
			self._serverWatchMap = {};
			if(unwatchRequests.length > 0) {
				self._wsSocket.emit('unwatchLocal', unwatchRequests);
			}
		} else if(!handler) {
			if(self._serverWatchMap[event]) {
				unwatchRequests.push({
					remote: true,
					host: self._wsClient.host,
					port: self._wsClient.port,
					secure: self._wsClient.secure,
					wsEndpoint: self._wsClient.wsEndpoint,
					ns: self._namespace,
					event: event
				});
				
				delete self._serverWatchMap[event];
				if(unwatchRequests.length > 0) {
					self._wsSocket.emit('unwatchLocal', unwatchRequests);
				}
			}
		} else {
			if(self._serverWatchMap[event]) {
				var len = self._serverWatchMap[event].length;
				var newEventList = [];
				for(i=0; i<len; i++) {
					if(self._serverWatchMap[event][i] == handler) {
						unwatchRequests.push({
							remote: true,
							host: self._wsClient.host,
							port: self._wsClient.port,
							secure: self._wsClient.secure,
							wsEndpoint: self._wsClient.wsEndpoint,
							ns: self._namespace,
							event: event
						});
					} else {
						newEventList.push(self._serverWatchMap[event][i]);
					}
				}
				
				if(unwatchRequests.length > 0) {
					if(newEventList < 1) {
						self._wsSocket.emit('unwatchLocal', unwatchRequests);
					}
					self._serverWatchMap[event] = newEventList;
				}
			}
		}
	}
	
	self._getWatcher = function(event, handler) {
		if(!event || !handler) {
			throw "Exception: One or more required parameters were undefined";
		}
		
		if(self._serverWatchMap[event]) {
			var watchers = self._serverWatchMap[event];
			var len = watchers.length;
			var i;
			for(i=0; i<len; i++) {
				if(watchers[i] == handler) {
					return watchers[i];
				}
			}
		}
		return null;
	}
	
	self.hasWatcher = function(event) {
		return self._serverWatchMap.hasOwnProperty(event);
	}
	
	self.isWatching = function(event, handler) {
		return self._getWatcher(event, handler) ? true : false;
	}
	
	self._triggerWatchers = function(event, data) {
		if(self._serverWatchMap && self._serverWatchMap[event]) {
			var watchers = self._serverWatchMap[event];
			var len = watchers.length;
			var i;
			for(i=0; i<len; i++) {
				watchers[i].call(null, data);
			}
		}
	}
}

var WebService = function() {
	var self = this;
	self._webServiceMap = {};
	self._watchMap = {};
	
	self._releaseMode = false;
	
	self.setReleaseMode = function(bool) {
		self._releaseMode = bool;
	}
	
	self._exec = function(siReq) {
		var client = self.getClient(siReq.request.host, siReq.request.port, siReq.request.secure, siReq.request.wsEndpoint);
		var serverInterface = siReq.request.si;
		var method = siReq.request.method;
		var data = siReq.request.data;
		
		var responseHandler = {
			success: function(data, finish) {
				if(finish) {
					siReq.end(data);
				} else {
					siReq.send(data);
				}
			},
			
			error: function(data, finish) {
				siReq.error(data, finish);
			}
		}
		
		client.connect(function() {
			client.exec(serverInterface, method, data, responseHandler);
		});
	}
	
	self.exec = function(siReq) {
		if(self._releaseMode) {
			try {
				self._exec(siReq);
			} catch(e) {
				console.log(e);
				self.emit('fail', e);
			}
		} else {
			self._exec(siReq);
		}
	}
	
	self.watch = function(siReq) {
		var request = siReq.request;
		var client = self.getClient(request.host, request.port, request.secure, request.wsEndpoint);
		
		var eventData = {
			remote: true,
			host: request.host,
			port: request.port,
			secure: request.secure,
			wsEndpoint: request.wsEndpoint,
			ns: request.ns,
			event: request.event
		}
		
		var handler = function(data) {
			eventData.data = data;
			siReq.session.ns(request.ns).emitRaw(eventData);
		}
		
		if(!self._watchMap.hasOwnProperty(siReq.session.id)) {
			self._watchMap[siReq.session.id] = [];
		}
		self._watchMap[siReq.session.id].push({ns: request.ns, event: request.event, client: client, handler: handler});
		
		client.connect(function() {
			client.ns(request.ns).watch(request.event, handler);
		});
	}
	
	self.unwatch = function(requests, socket) {
		var len = requests.length;
		var i, client, request;
		for(i=0; i<len; i++) {
			request = requests[i];
			client = self.getClient(request.host, request.port, request.secure, request.wsEndpoint);
			
			if(socket) {
				if(self._watchMap.hasOwnProperty(socket.id)) {
					var watchers = [];
					var j, curWatcher;
					
					for(j in self._watchMap[socket.id]) {
						curWatcher = self._watchMap[socket.id][j];
						if(!(curWatcher.ns == request.ns && curWatcher.event == request.event)) {
							watchers.push(curWatcher);
						}
					}
					
					self._watchMap[socket.id] = watchers;
				}
			}
			
			client.connect(function() {
				client.ns(request.ns).unwatch(request.event);
			});
		}
	}
	
	self.unwatchAll = function(socket) {
		var i, curWatcher;
		for(i in self._watchMap[socket.id]) {
			curWatcher = self._watchMap[socket.id][i];
			curWatcher.client.ns(curWatcher.ns).unwatch(curWatcher.event, curWatcher.handler);
		}
		self._watchMap[socket.id] = [];
	}
	
	self.getClient = function(host, port, secure, wsEndpoint) {
		if(!wsEndpoint) {
			wsEndpoint = '/ws';
		}
		
		var url = (secure ? 'https://' : 'http://') + host + ":" + port + wsEndpoint;
		if(!self._webServiceMap.hasOwnProperty(url)) {
			self._webServiceMap[url] = new WebServiceClient(host, port, secure, wsEndpoint);
		}
		return self._webServiceMap[url];
	}
}

WebService.prototype.__proto__ = EventEmitter.prototype;

module.exports = new WebService();
