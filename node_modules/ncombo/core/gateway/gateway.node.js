var path = require('path'),
	fs = require('fs'),
	Eventer = require(__dirname + '/../event_dispatcher.node.js'),
	io = require(__dirname + '/../../../socket.io/node_modules/socket.io-client/lib/socket.io-client.js');

var Gateway = new (function() {
	var self = this;
	self._siDir = null;
	self._eventer = new Eventer();
	self._serverInterfaces = {};
	self._privateExtension = /$a/;
	self._allowedMap = {'*': true};
	self._releaseMode = false;
	
	self._serverWatchMap = {};
	self._serverWatchers = {};
	
	self.init = function(serverInterfaceDir, privateExtensionRegex) {
		self._siDir = path.normalize(serverInterfaceDir);
		
		if(privateExtensionRegex) {
			self._privateExtension = privateExtensionRegex;
		}
		
		var serverInterfaceFiles = fs.readdirSync(self._siDir);
		var i, file, siName;
		var privateExt = new RegExp('(.*)' + self._privateExtension.source);
		for(i in serverInterfaceFiles) {
			file = serverInterfaceFiles[i];
			match = file.match(privateExt);
			if(match) {
				siName = match[1];
				self._serverInterfaces[siName] = require(self._siDir + file);
			}
		}
	}
	
	self.releaseMode = function(bool) {
		self._releaseMode = bool;
	}
	
	self.restrict = function() {
		self._allowedMap = {'*': false};
	}
	
	self.unrestrict = function() {
		self._allowedMap = {'*': true};
	}
	
	self.allow = function(serverInterface, method) {
		if(!method) {
			self._allowedMap[serverInterface] = {};
			self._allowedMap[serverInterface]['*'] = true;
		} else {
			if(!self._allowedMap.hasOwnProperty(serverInterface)) {
				self._allowedMap[serverInterface] = {};
			}
			self._allowedMap[serverInterface][method] = true;
		}
	}
	
	self.forbid = function(serverInterface, method) {
		if(!method) {
			self._allowedMap[serverInterface] = {};
			self._allowedMap[serverInterface]['*'] = false;
		} else {
			if(!self._allowedMap.hasOwnProperty(serverInterface)) {
				self._allowedMap[serverInterface] = {};
			}
			self._allowedMap[serverInterface][method] = false;
		}
	}
	
	self.isAllowed = function(serverInterface, method) {
		var permissive = self._allowedMap['*'];
		
		if(self._allowedMap.hasOwnProperty(serverInterface)) {
			var allowedClass = self._allowedMap[serverInterface].hasOwnProperty('*') ? self._allowedMap[serverInterface]['*'] : permissive;
			var allowedMethod = self._allowedMap[serverInterface].hasOwnProperty(method) ? self._allowedMap[serverInterface][method] : allowedClass;
		} else {
			var allowedMethod = permissive;
		}
		
		return allowedMethod;
	}
	
	self.watchForbidden = function(listener) {
		var event = 'forbidden';
		self._eventer.on(event, listener);
	}
	
	self.unwatchForbidden = function(listener) {
		var event = 'forbidden';
		self._eventer.off(event, listener);
	}
	
	self.watchError = function(listener) {
		var event = 'error';
		self._eventer.on(event, listener);
	}
	
	self.unwatchError = function(listener) {
		var event = 'error';
		self._eventer.off(event, listener);
	}
	
	self._call = function(serverInterface, method, data, request) {
		if(self.isAllowed(serverInterface, method)) {
			self._serverInterfaces[serverInterface][method](request, data);
		} else {
			self._eventer.dispatchEvent('forbidden', request);
			throw "Exception: Unauthorized call to '" + method + "' method of '" + serverInterface + "' server interface";
		}
	}
	
	self.call = function(serverInterface, method, data, request) {
		if(self._releaseMode) {
			try {
				self._call(serverInterface, method, data, request);
			} catch(e) {
				console.log(e);
				self._eventer.dispatchEvent('error', e);
			}
		} else {
			self._call(serverInterface, method, data, request);
		}
	}
	
	self.getWatchers = function() {
		var watchers = [];
		
		var ns = null;
		var event = null;
		if(arguments.length > 1) {
			ns = arguments[0];
			event = arguments[1];
			
			if(!ns) {
				ns = '__main';
			}
		} else if(arguments.length > 0) {
			ns = arguments[0];
			if(!ns) {
				ns = '__main';
			}
		}
	
		var i, j, k, id;
		
		if(!ns) {
			for(id in self._serverWatchers) {
				for(ns in self._serverWatchers[id]) {
					for(event in self._serverWatchers[id][ns]) {
						watchers.push(self._serverWatchMap[ns][event][id].socket);
						break;
					}
					break;
				}
			}
		} else if(!event) {
			for(j in self._serverWatchMap[ns]) {
				for(k in self._serverWatchMap[ns][j]) {
					watchers.push(self._serverWatchMap[ns][j][k].socket);
				}
			}
		} else {
			if(self._serverWatchMap[ns]) {
				var eventWatchers = self._serverWatchMap[ns][event];
				if(eventWatchers) {
					for(i in eventWatchers) {
						watchers.push(eventWatchers[i].socket);
					}
				}
			}
		}
		
		return watchers;
	}
	
	self._watch = function(socket, request) {
		var ns = request.ns;
		var event = request.event;
		var id = socket.id;
		if(!self._serverWatchMap.hasOwnProperty(ns)) {
			self._serverWatchMap[ns] = {};
		}
		
		if(!self._serverWatchMap[ns].hasOwnProperty(event)) {
			self._serverWatchMap[ns][event] = {};
		}
		
		if(self._serverWatchMap[ns][event].hasOwnProperty(id)) {
			self._serverWatchMap[ns][event][id].count++;
		} else {
			self._serverWatchMap[ns][event][id] = {socket: socket, count: 1};
			
			if(!self._serverWatchers.hasOwnProperty(id)) {
				self._serverWatchers[id] = {};
			}
			
			if(!self._serverWatchers[id].hasOwnProperty(ns)) {
				self._serverWatchers[id][ns] = {};
			}
			
			self._serverWatchers[id][ns][event] = true;
		}
	}
	
	self._cleanupWatchMap = function(ns, event) {
		var i;
		var isEmpty = true;
		for(i in self._serverWatchMap[ns][event]) {
			isEmpty = false;
			break;
		}
		if(isEmpty) {
			delete self._serverWatchMap[ns][event];
		}
		
		isEmpty = true;
		for(i in self._serverWatchMap[ns]) {
			isEmpty = false;
			break;
		}
		if(isEmpty) {
			delete self._serverWatchMap[ns];
		}
	}
	
	self._cleanupWatchers = function(id, ns) {
		var i;
		var isEmpty = true;
		for(i in self._serverWatchers[id][ns]) {
			isEmpty = false;
			break;
		}
		if(isEmpty) {
			delete self._serverWatchers[id][ns];
		}
		
		isEmpty = true;
		for(i in self._serverWatchers[id]) {
			isEmpty = false;
			break;
		}
		if(isEmpty) {
			delete self._serverWatchers[id];
		}
	}
	
	self._unwatch = function(socket, requests) {
		var id = socket.id;
		var i, req, isEmpty, ns, event;
		
		for(i in requests) {
			req = requests[i];
			ns = req.ns;
			event = req.event;
			
			if(self._serverWatchMap[ns] && self._serverWatchMap[ns].hasOwnProperty(event) && self._serverWatchMap[ns][event].hasOwnProperty(id)) {
				if(self._serverWatchMap[ns][event][id].count > 1) {
					self._serverWatchMap[ns][event][id].count--;
				} else {
					delete self._serverWatchMap[ns][event][id];
					delete self._serverWatchers[id][ns][event];
				}
				self._cleanupWatchMap(ns, event);
				self._cleanupWatchers(id, ns);
			}
		}
	}
	
	self._unwatchAll = function(socket) {
		var ns, event, isEmpty;
		var id = socket.id;
		
		for(ns in self._serverWatchers[id]) {
			for(event in self._serverWatchers[id][ns]) {
				delete self._serverWatchMap[ns][event][id];
				delete self._serverWatchers[id][ns][event];
				self._cleanupWatchMap(ns, event);
			}
			delete self._serverWatchers[id][ns];
		}
		delete self._serverWatchers[id];
	}
})();

module.exports = Gateway;