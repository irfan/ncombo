var path = require('path'),
	fs = require('fs'),
	ndata = require('ndata'),
	io = require(__dirname + '/../../../socket.io/node_modules/socket.io-client/lib/socket.io-client.js'),
	EventEmitter = require('events').EventEmitter;

var Gateway = function() {
	var self = this;
	self._siDir = null;
	self._dataClient = null;
	self._serverInterfaces = {};
	self._privateExtension = /$a/;
	self._allowedMap = {'*': true};
	self._releaseMode = false;
	
	self._serverWatchers = {};
	
	self.init = function(serverInterfaceDir, dataClient, privateExtensionRegex) {
		self._siDir = path.normalize(serverInterfaceDir);
		self._dataClient = dataClient;
		
		if(privateExtensionRegex) {
			self._privateExtension = privateExtensionRegex;
		}
		
		var serverInterfaceFiles = fs.readdirSync(self._siDir);
		var i, file, siName;
		var privateExt = new RegExp('(.*)' + self._privateExtension.source);
		for(i in serverInterfaceFiles) {
			file = serverInterfaceFiles[i];
			match = file.match(privateExt);
			if(match) {
				siName = match[1];
				self._serverInterfaces[siName] = require(self._siDir + file);
			}
		}
	}
	
	self.setReleaseMode = function(bool) {
		self._releaseMode = bool;
	}
	
	self._exec = function(siReq) {
		var serverInterface = siReq.request.si;
		var method = siReq.request.method;
		var data = siReq.request.data;
		
		self._serverInterfaces[serverInterface][method](siReq, data);
	}
	
	self.exec = function(siReq) {
		if(self._releaseMode) {
			try {
				self._exec(siReq);
			} catch(e) {
				console.log(e);
				self.emit('fail', e);
			}
		} else {
			self._exec(siReq);
		}
	}
	
	self.watch = function(siReq) {
		var ns = siReq.request.ns;
		var event = siReq.request.event;
		var id = siReq.socket.id;
		
		var socketEmit = function(ns, event, value) {
			siReq.session.ns(ns).emit(event, value);
		}
		
		if(!self._serverWatchers.hasOwnProperty(id)) {
			self._serverWatchers[id] = {};
		}
		
		var eventString = 'session ' + id + ' ' + ns + '.' + event;
		var handler = function(value) {
			socketEmit(ns, event, value);
		}
		
		self._serverWatchers[id][eventString] = true;
		
		self._dataClient.watch(eventString, handler);
	}
	
	self.unwatch = function(socket, requests) {
		var id = socket.id;
		var i, req, isEmpty, ns, event, eventString;
		
		for(i in requests) {
			req = requests[i];
			ns = req.ns;
			event = req.event;
			
			eventString = 'session ' + id + ' ' + ns + '.' + event;
			if(self._serverWatchers[id] && self._serverWatchers[id][eventString]) {
				delete self._serverWatchers[id][eventString];
			}
			
			self._dataClient.unwatch(eventString);
		}
	}
	
	self.unwatchAll = function(socket) {
		var ns, event, isEmpty;
		var id = socket.id;
		
		var j;
		for(j in self._serverWatchers[id]) {
			self._dataClient.unwatch(j);
			delete self._serverWatchers[id][j];
		}
		delete self._serverWatchers[id];
	}
}

Gateway.prototype.__proto__ = EventEmitter.prototype;

module.exports = new Gateway();
