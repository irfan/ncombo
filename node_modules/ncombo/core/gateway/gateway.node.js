var path = require('path'),
	fs = require('fs'),
	ndata = require('ndata'),
	io = require('socket.io-client'),
	EventEmitter = require('events').EventEmitter;

var Gateway = function() {
	var self = this;
	self._siDir = null;
	self._dataClient = null;
	self._serverInterfaces = {};
	self._privateExtension = /$a/;
	self._allowedMap = {'*': true};
	self._releaseMode = false;
	
	self._serverWatchers = {};
	
	self.init = function(serverInterfaceDir, dataClient, privateExtensionRegex) {
		self._siDir = path.normalize(serverInterfaceDir);
		self._dataClient = dataClient;
		
		if(privateExtensionRegex) {
			self._privateExtension = privateExtensionRegex;
		}
		
		var serverInterfaceFiles = fs.readdirSync(self._siDir);
		var i, file, siName;
		var privateExt = new RegExp('(.*)' + self._privateExtension.source);
		for(i in serverInterfaceFiles) {
			file = serverInterfaceFiles[i];
			match = file.match(privateExt);
			if(match) {
				siName = match[1];
				self._serverInterfaces[siName] = require(self._siDir + file);
			}
		}
	}
	
	self.setReleaseMode = function(bool) {
		self._releaseMode = bool;
	}
	
	self._exec = function(siReq) {
		var serverInterface = siReq.request.si;
		var method = siReq.request.method;
		var data = siReq.request.data;
		self._serverInterfaces[serverInterface][method](siReq, data);
	}
	
	self.exec = function(siReq) {
		try {
			self._exec(siReq);
		} catch(e) {			
			if(e.stack) {
				siReq.collapse(e.stack);
				console.log(e.stack);
			} else {
				siReq.collapse(e);
				console.log(e);
			}
		}
	}
	
	self.watch = function(siReq) {
		var ns = siReq.request.ns;
		var event = siReq.request.event;
		var id = siReq.socket.id;
		
		var socketEmit = function(value) {
			siReq.session.ns(ns).emit(event, value);
		}
		
		var eventString = 'session ' + id + '.' + ns + '.' + event;
		var handler = function(value) {
			socketEmit(value);
		}
		
		self._dataClient.watch(eventString, handler, function(err) {
			if(!err) {
				if(!self._serverWatchers.hasOwnProperty(id)) {
					self._serverWatchers[id] = {};
				}
				self._serverWatchers[id][eventString] = true;
			}
			siReq.end(err);
		});
	}
	
	self.unwatch = function(siReq) {
		var socket = siReq.socket;
		var requests = siReq.request.requests;
		var id = socket.id;
		var i, req, ns, event, eventString;
		var events = [];
		
		var successCount = 0;
		var failEmitted = false;
		
		if(requests.length > 0) {
			for(i in requests) {
				req = requests[i];
				ns = req.ns;
				event = req.event;
				events.push(event);
				
				eventString = 'session ' + id + '.' + ns + '.' + event;
				if(self._serverWatchers[id] && self._serverWatchers[id][eventString]) {
					delete self._serverWatchers[id][eventString];
				}
				self._dataClient.unwatch(eventString, null, siReq.end);
			}
		} else {
			siReq.end();
		}
	}
	
	self.unwatchAll = function(socket, ackCallback) {
		var ns, event;
		var id = socket.id;
		
		var successCount = 0;
		var failEmitted = false;
		
		var i;
		var numReqs = 0;
		for(i in self._serverWatchers[id]) {
			numReqs++;
		}
		for(i in self._serverWatchers[id]) {
			self._dataClient.unwatch(i, null, function(err) {
				if(err) {
					if(!failEmitted) {
						if(ackCallback) {
							ackCallback();
						}
						failEmitted = true;
					}
				} else {
					if(++successCount >= numReqs) {
						if(ackCallback) {
							ackCallback(err);
						}
					}
				}
			});
			
			delete self._serverWatchers[id][i];
		}
		delete self._serverWatchers[id];
	}
}

Gateway.prototype.__proto__ = EventEmitter.prototype;

module.exports = new Gateway();
