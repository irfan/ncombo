var fs = require('fs'),
	path = require('path'),
	mime = require('mime'),
	less = require('less'),
	cache = require('ncombo/core/cache');

var Router = new (function() {
	var self = this;
	self._privateExtension = /$a/;
	self._defaultRootDir = __dirname + '/../../../../';
	
	self._options = {};
	self._rootDirPath = self._defaultRootDir;
	self._protocol = 'http';	
	self._cacheMode = false;
	
	self._cacheAndRespond = function(res, filePath, data) {
		if(self._cacheMode) {
			cache.setFile(filePath, data);
		}
		
		if(!res.finished) {
			res.end(data);
		}
	}
	
	self._urlToPath = function(url) {
		url = url.replace(/\?.*/, '');
		return self._rootDirPath + url;
	}
	
	self._setFileResponseHeaders = function(res, filePath) {	
		var mimeType = mime.lookup(filePath);
		
		if(self._cacheMode) {
			var now = new Date();
			var oneMonth = new Date(now.getTime() + 2592000000);
			
			res.setHeader('Cache-Control', 'public');
			res.setHeader('Pragma', 'public');
			res.setHeader('Expires', oneMonth.toUTCString());
		} else {
			res.setHeader('Pragma', 'no-cache');
			res.setHeader('Cache-Control', 'no-cache, must-revalidate');
		}
		
		res.writeHead(200, {'Content-Type': mimeType});
	}
	
	self.getOptions = function() {
		return self._options;
	}
	
	self.start = function(options) {
		if(options) {
			self._options = options;
			self._cacheMode = self._options.release ? true : false;
			if(self._options.protocol) {
				self._protocol = self._options.protocol;
			}
			if(self._options.privateExtensionRegex) {
				self._privateExtension = self._options.privateExtensionRegex;
			}
			if(self._options.rootDirPath) {
				self._rootDirPath = self._options.rootDirPath;
			}
		}
	}
	
	self.rout = function(req, res) {
		var filePath = self._urlToPath(req.url);
		
		if(self._privateExtension && self._privateExtension.test(req.url)) {
			res.writeHead(403);
			res.end('Request ' + req.url + ' refers to a private resource which cannot be accessed directly');
		} else {
			if(self._cacheMode && cache.hasFile(filePath)) {
				self._setFileResponseHeaders(res, filePath);
				if(!res.finished) {
					res.end(cache.getFile(filePath));
				}
			} else {
				fs.readFile(filePath, function(err, data) {
					if(err) {
						if(err.code == 'ENOENT') {
							res.writeHead(404);
							res.end('Resource ' + req.url + ' could not be found');
						} else {
							res.writeHead(500);
							res.end('Could not access ' + req.url);
						}
					} else {
						var ext = filePath.match(self._extRegex);
						ext = ext ? ext[0] : '';
						
						self._setFileResponseHeaders(res, filePath);
						
						if(ext == '.less') {
							less.render(data.toString(), function (e, css) {
								self._cacheAndRespond(res, filePath, css);
							});
						} else {
							self._cacheAndRespond(res, filePath, data);
						}
					}
				});
			}
		}
	}
	
	self._redirect = function(req, res, url) {
		res.writeHead(301, {'Location': self._protocol + '://' + req.headers.host + url});
		res.end();
	}
})();

module.exports = Router;