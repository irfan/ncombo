var io = require('socket.io-client'),
	path = require('path'),
	EventEmitter = require('events').EventEmitter;

var WebServiceClient = function(host, port, secure, wsEndpoint) {
	var self = this;
	self._wsSocket = null;
	self._mainNamespace = null;
	self._namespaces = {};
	self._callTracker = {};
	self._callback = null;
	
	self._connectFailedMessage = 'Failed to connect to web service';
	
	self._timeout = 10000;
	
	self.host = host;
	self.port = port;
	self.secure = secure;
	self.wsEndpoint = wsEndpoint;
	
	self.MAX_ID = Math.pow(2, 53) - 2;
	self._curID = 1;
	self._genID = function() {
		self._curID++;
		self._curID = self._curID % self.MAX_ID;
		return 'r' + self._curID;
	}
	
	self.setTimeout = function(timeout) {
		self._timeout = timeout;
	}
	
	self.asClientURL = function(clientDesc) {
		return (clientDesc.secure ? 'https://' : 'http://') + clientDesc.host + ":" + clientDesc.port + clientDesc.wsEndpoint;
	}
	
	self._wsURL = self.asClientURL({host: host, port: port, secure: secure, wsEndpoint: wsEndpoint});
	
	self.getURL = function() {
		return self._wsURL;
	}
	
	self.disconnect = function(callback) {
		var cleanupHandler = function(err) {
			if(self._wsSocket) {
				self._wsSocket.removeListener('return', self._callReturn);
				self._wsSocket.removeListener('event', self._eventReceived);
			}
		}
		
		if(self._wsSocket && self._wsSocket.socket.connected) {
			self._destroy(function(err) {
				if(err) {
					callback && callback(err);
				} else {
					if(self._wsSocket) {
						self._callTracker = {};
						cleanupHandler();
						self._wsSocket.on('disconnect', function() {
							self._wsSocket.socket.connected = false;
							callback && callback(err);
							self.emit('disconnect');
						});
						self._wsSocket.disconnect();
					} else {
						self._callTracker = {};
						callback && callback(err);
						self.emit('disconnect');
					}
				}
			});
		} else {
			self._callTracker = {};
			cleanupHandler();
			callback && callback(err);
			self.emit('disconnect');
		}
	}
	
	self._listenForSocketEvents = function() {
		if(self._wsSocket.listeners('return').length < 1) {
			self._wsSocket.on('return', self._callReturn);
		}
		if(self._wsSocket.listeners('event').length < 1) {
			self._wsSocket.on('event', self._eventReceived);
		}
	}
	
	self._connect = function(callback) {
		self._wsSocket = io.connect(self._wsURL, {'connect timeout': self._timeout});
		self._mainNamespace = self.ns('__main');
		self._namespaces = {'__main': self._mainNamespace};
		
		self._listenForSocketEvents();
		
		var connectHandler = function() {
			self._wsSocket.removeListener('connect', connectHandler);
			self._wsSocket.removeListener('connect_failed', connectFailHandler);
			self.emit('connection');
			callback && callback();
		}
		
		var connectFailHandler = function() {
			self._wsSocket.removeListener('connect', connectHandler);
			self._wsSocket.removeListener('connect_failed', connectFailHandler);
			self.emit('connect_failed');
			callback && callback(self._connectFailedMessage);
		}
		
		self._wsSocket.on('connect', connectHandler);
		self._wsSocket.on('connect_failed', connectFailHandler);
	}
	
	self.connect = function(callback) {
		var id = self._genID();
		
		if(self._wsSocket) {
			if(self._wsSocket.socket.connected) {
				callback && callback();
			} else if(self._wsSocket.socket.connecting) {
				self._wsSocket.on('connect', function() {
					callback && callback();
				});
				self._wsSocket.on('connect_failed', function() {
					callback && callback(self._connectFailedMessage);
				});
			} else {
				self._connect(callback);
			}
		} else {
			self._connect(callback);
		}
	}
	
	self._callReturn = function(data) {
		var cid = data.cid;
		if(self._callTracker[cid]) {
			if(!data.noValue) {
				var finish = data.close ? true : false;
				if(self._callTracker[cid]) {
					self._callTracker[cid](data.error, data.value, finish);
				}
			}
			if(data.close) {
				delete self._callTracker[cid];
			}
		}
	}
	
	self.trackRequest = function(cid, callback) {
		self._callTracker[cid] = callback;
	}
	
	self._eventReceived = function(event) {
		self.ns(event.ns)._triggerWatchers(event.event, event.data);
	}
	
	self.isConnected = function() {
		return self._wsSocket && self._wsSocket.socket.connected;
	}
	
	self.exec = function() {
		var serverInterface = arguments[0];
		var method = arguments[1];
		var data = null;
		var cid = self._genID();
		
		if(arguments[3]) {
			data = arguments[2];
			var callback = arguments[3];
			self._callTracker[cid] = callback;
		} else if(arguments[2]) {
			if(arguments[2] instanceof Function) {
				var callback = arguments[2];
				self._callTracker[cid] = callback;
			} else {
				data = arguments[2];
			}
		}
		
		var request = {
			remote: true,
			host: host,
			port: port,
			secure: secure,
			wsEndpoint: wsEndpoint,
			si: serverInterface,
			method: method,
			data: data,
			cid: cid
		};
		self.connect(function(err) {
			if(err) {
				if(self._callTracker[cid]) {
					self._callTracker[cid](err, null, true);
					delete self._callTracker[cid];
				}
			} else {
				self._wsSocket.emit('localCall', request);
			}
		});
	}
	
	self.ns = function(namespace) {
		if(!self._namespaces[namespace]) {
			self._namespaces[namespace] = new NS(namespace, self._wsSocket, self);
		} else {
			self._namespaces[namespace].setSocket(self._wsSocket);
		}
		return self._namespaces[namespace];
	}
	
	self.watch = function() {
		self._mainNamespace.watch.apply(null, arguments);
	}
	
	self.unwatch = function() {
		self._mainNamespace.unwatch.apply(null, arguments);
	}
	
	self._destroy = function(ackCallback) {
		var i;
		var nsCount = 0;
		var nsSuccess = 0;
		var emittedFail = false;
		for(i in self._namespaces) {
			nsCount++;
		}
		if(nsCount) {
			for(i in self._namespaces) {
				self._namespaces[i]._unwatch(null, null, function(err) {
					if(err) {
						if(!emittedFail) {
							ackCallback && ackCallback('Failed to unwatch all events');
							emittedFail = true;
						}
					} else {
						if(++nsSuccess >= nsCount) {
							ackCallback && ackCallback();
						}
					}
				});
			}
		} else {
			ackCallback && ackCallback();
		}
	}
	
	self.destroy = function(ackCallback) {
		self.connect(function(err) {
			if(err) {
				ackCallback && ackCallback(err);
			} else {
				self._destroy(ackCallback);
			}
		});
	}
	
	self.isWatching = function() {
		self._mainNamespace.isWatching.apply(null, arguments);
	}
}

WebServiceClient.prototype.__proto__ = EventEmitter.prototype;

var NS = function(namespace, wsSocket, wsClient) {
	var self = this;
	self._namespace = namespace;
	self._wsSocket = wsSocket;
	self._wsClient = wsClient;
	self._serverWatchMap = {};
	
	self.MAX_ID = Math.pow(2, 53) - 2;
	self._curID = 1;
	self._genID = function() {
		self._curID++;
		self._curID = self._curID % self.MAX_ID;
		return 'rn' + self._curID;
	}
	
	self.setSocket = function(socket) {
		self._wsSocket = socket;
	}
	
	self.watch = function(event, handler, ackCallback) {
		if(!event || !handler) {
			throw new Error("   Exception: One or more required parameters were undefined");
		}
		
		self._wsClient.connect(function(err) {
			if(err) {
				ackCallback && ackCallback(err);
			} else {
				if(!self._serverWatchMap.hasOwnProperty(event)) {
					self._serverWatchMap[event] = [];
				}
				self._serverWatchMap[event].push(handler);
				
				var ackHandler = function(err) {
					if(err) {
						delete self._serverWatchMap[event];
					}
					ackCallback && ackCallback(err);
				}
				
				if(self._serverWatchMap[event].length < 2) {
					var cid = self._genID();
					var request = {
						remote: true,
						host: self._wsClient.host,
						port: self._wsClient.port,
						secure: self._wsClient.secure,
						wsEndpoint: self._wsClient.wsEndpoint,
						ns: self._namespace,
						event: event,
						cid: cid
					};
					
					self._wsClient.trackRequest(cid, ackHandler);
					self._wsSocket.emit('watchLocal', request);
				} else {
					ackCallback && ackCallback();
				}
			}
		});
	}
	
	self._unwatch = function(event, handler, ackCallback) {
		var i, j;
		var cid = self._genID();
		var unwatchRequest = {cid: cid, requests: []};
		
		if(!event) {
			for(j in self._serverWatchMap) {
				unwatchRequest.requests.push({
					remote: true,
					host: self._wsClient.host,
					port: self._wsClient.port,
					secure: self._wsClient.secure,
					wsEndpoint: self._wsClient.wsEndpoint,
					ns: self._namespace,
					event: j
				});
			}
			self._serverWatchMap = {};
			if(unwatchRequest.requests.length > 0) {
				self._wsClient.trackRequest(cid, ackCallback);
				self._wsSocket.emit('unwatchLocal', unwatchRequest);
			} else {
				ackCallback && ackCallback();
			}
		} else if(!handler) {
			if(self._serverWatchMap[event]) {
				unwatchRequest.requests.push({
					remote: true,
					host: self._wsClient.host,
					port: self._wsClient.port,
					secure: self._wsClient.secure,
					wsEndpoint: self._wsClient.wsEndpoint,
					ns: self._namespace,
					event: event
				});
				
				delete self._serverWatchMap[event];
				if(unwatchRequest.requests.length > 0) {
					self._wsClient.trackRequest(cid, ackCallback);
					self._wsSocket.emit('unwatchLocal', unwatchRequest);
				} else {
					ackCallback && ackCallback();
				}
			} else {
				ackCallback && ackCallback();
			}
		} else {
			if(self._serverWatchMap[event]) {
				var len = self._serverWatchMap[event].length;
				var newEventList = [];
				for(i=0; i<len; i++) {
					if(self._serverWatchMap[event][i] == handler) {
						unwatchRequest.requests.push({
							remote: true,
							host: self._wsClient.host,
							port: self._wsClient.port,
							secure: self._wsClient.secure,
							wsEndpoint: self._wsClient.wsEndpoint,
							ns: self._namespace,
							event: event
						});
					} else {
						newEventList.push(self._serverWatchMap[event][i]);
					}
				}
				
				if(unwatchRequest.requests.length > 0) {
					if(newEventList < 1) {
						self._wsClient.trackRequest(cid, ackCallback);
						self._wsSocket.emit('unwatchLocal', unwatchRequest);
					} else {
						ackCallback && ackCallback();
					}
					self._serverWatchMap[event] = newEventList;
				} else {
					ackCallback && ackCallback();
				}
			} else {
				ackCallback && ackCallback();
			}
		}
	}
	
	self.unwatch = function(event, handler, ackCallback) {
		self._wsClient.connect(function(err) {
			if(err) {
				ackCallback && ackCallback(err);
			} else {
				self._unwatch(event, handler, ackCallback);
			}
		});
	}
	
	self._getWatcher = function(event, handler) {
		if(!event || !handler) {
			throw "Exception: One or more required parameters were undefined";
		}
		if(self._serverWatchMap[event]) {
			var watchers = self._serverWatchMap[event];
			var len = watchers.length;
			var i;
			for(i=0; i<len; i++) {
				if(watchers[i] == handler) {
					return watchers[i];
				}
			}
		}
		return null;
	}
	
	self.isWatching = function(event, handler) {
		if(handler) {
			return self._getWatcher(event, handler) ? true : false;
		} else {
			return self._serverWatchMap.hasOwnProperty(event);
		}
	}
	
	self._triggerWatchers = function(event, data) {
		if(self._serverWatchMap && self._serverWatchMap[event]) {
			var watchers = self._serverWatchMap[event];
			var len = watchers.length;
			var i;
			for(i=0; i<len; i++) {
				watchers[i].call(null, data);
			}
		}
	}
}

var WebService = function() {
	var self = this;
	self._webServiceMap = {};
	self._watchMap = {};
	
	self._releaseMode = false;
	self._timeout = 10000;
	
	self.setReleaseMode = function(bool) {
		self._releaseMode = bool;
	}
	
	self.setTimeout = function(timeout) {
		self._timeout = timeout;
	}
	
	self.isEmpty = function(object) {
		var i;
		var empty = true;
		for(i in object) {
			empty = false;
			break;
		}
		return empty;
	}
	
	self.exec = function(siReq) {
		var client = self.getClient(siReq.host, siReq.port, siReq.secure, siReq.wsEndpoint);
		var serverInterface = siReq.si;
		var method = siReq.method;
		var data = siReq.data;
		
		var callback = function(err, data, finish) {
			if(err) {
				siReq.error(err, finish);
				console.log(err);
			} else {
				if(finish) {
					siReq.end(data);
				} else {
					siReq.send(data);
				}
			}
		}
		
		client.connect(function(err) {
			if(err) {
				callback(err, null, true);
			} else {
				client.exec(serverInterface, method, data, callback);
			}
		});
	}
	
	self.watch = function(siReq) {
		var id = siReq.session.id;
		var client = self.getClient(siReq.host, siReq.port, siReq.secure, siReq.wsEndpoint);
		var emittedFail = false;
		
		var eventData = {
			remote: true,
			host: siReq.host,
			port: siReq.port,
			secure: siReq.secure,
			wsEndpoint: siReq.wsEndpoint,
			ns: siReq.ns,
			event: siReq.event
		}
		
		var handler = function(data) {
			eventData.data = data;
			siReq.session.ns(siReq.ns).emitRaw(eventData);
		}
		
		if(client.ns(siReq.ns).isWatching(siReq.event)) {
			siReq.end();
		} else {
			client.ns(siReq.ns).watch(siReq.event, handler, function(err) {
				if(err) {
					if(!emittedFail) {
						siReq.error(err, true);
						emittedFail = true;
					}
				} else {
					if(!self._watchMap.hasOwnProperty(id)) {
						self._watchMap[id] = [];
					}
					self._watchMap[id].push({ns: siReq.ns, event: siReq.event, client: client, handler: handler});
					
					siReq.end();
				}
			});
		}
	}
	
	self.unwatch = function(siReq) {
		var socket = siReq.socket;
		var id = siReq.session.id;
		var requests = siReq.requests;
		var len = requests.length;
		var successCount = 0;
		var emittedFail = false;
		var i, client, request;
		for(i=0; i<len; i++) {
			request = requests[i];
			client = self.getClient(request.host, request.port, request.secure, request.wsEndpoint);
			
			if(socket) {
				if(self._watchMap.hasOwnProperty(id)) {
					var watchers = [];
					var j, curWatcher;
					
					for(j in self._watchMap[id]) {
						curWatcher = self._watchMap[id][j];
						if(!(curWatcher.ns == request.ns && curWatcher.event == request.event)) {
							watchers.push(curWatcher);
						}
					}
					
					self._watchMap[id] = watchers;
				}
			}
			
			client.ns(request.ns).unwatch(request.event, null, function(err) {
				if(err) {
					if(!emittedFail) {
						siReq.error(err, true);
						emittedFail = true;
					}
				} else {
					if(++successCount >= len) {
						siReq.end();
					}
				}
			});
		}
	}
	
	self.destroy = function(session, ackCallback) {
		var id = session.id;
		var i, curWatcher;
		var successCount = 0;
		var failEmitted = false;
		
		var cleanupHandler = function(err, client) {
			delete self._watchMap[id];
			ackCallback && ackCallback(err);
			if(self.isEmpty(self._watchMap)) {
				client.disconnect();
			}
		}
		
		var numReqs = 0;
		for(i in self._watchMap[id]) {
			numReqs++;
		}
		for(i in self._watchMap[id]) {
			curWatcher = self._watchMap[id][i];
			curWatcher.client.ns(curWatcher.ns).unwatch(curWatcher.event, curWatcher.handler, function(err) {
				if(err) {
					if(!failEmitted) {
						failEmitted = true;
					}
				} else {
					if(++successCount >= numReqs) {
						cleanupHandler(null, curWatcher.client);
					}
				}
			});
		}
	}
	
	self.getClient = function(host, port, secure, wsEndpoint) {
		if(!wsEndpoint) {
			wsEndpoint = '/ws';
		}
		
		var url = (secure ? 'https://' : 'http://') + host + ":" + port + wsEndpoint;
		if(!self._webServiceMap.hasOwnProperty(url)) {
			self._webServiceMap[url] = new WebServiceClient(host, port, secure, wsEndpoint);
			self._webServiceMap[url].setTimeout(self._timeout);
		}
		
		return self._webServiceMap[url];
	}
}

WebService.prototype.__proto__ = EventEmitter.prototype;

module.exports = new WebService();
