var fs = require('fs'),
	path = require('path'),
	mime = require('mime'),
	zlib = require('zlib'),
	less = require('less'),
	wrench = require('wrench'),
	jsp = require("uglify-js").parser,
	pro = require("uglify-js").uglify,
	SmartCacheManager = require("ncombo/smartcachemanager").SmartCacheManager,
	cache = require('ncombo/cache');

var Router = new (function() {
	var self = this;
	self._privateExtension = /$a/;
	self._extRegex = /[.][^.]*$/;
	self._defaultRootDir = __dirname + '/../../../';
	
	self._options = {};
	self._rootDirPath = self._defaultRootDir;
	self._protocol = 'http';
	self._releaseMode = false;
	self._cacheLife = 2592000000;
	self._cacheType = 'private';
	self._cacheVersionManager = null;
	
	self.respond = function(req, res, cacheKey, data, encoding) {
		var cacheRes = function(err, result) {
			if(err) {
				if(!res.finished) {
					res.writeHead(200);
					res.end(data);
				}
			} else {
				if(self._releaseMode && !req.params.ck) {
					cache.setFile(cacheKey, result);
				}
				if(!res.finished) {
					res.setHeader('Content-Encoding', encoding);
					res.end(result);
				}
			}
		}
		if(self._releaseMode && !req.params.ck && cache.hasFile(cacheKey)) {
			if(!res.finished) {
				res.setHeader('Content-Encoding', encoding);
				res.writeHead(200);
				res.end(cache.getFile(cacheKey));
			}
		} else {
			var compressRespond = function(data) {
				if(encoding == 'gzip') {
					zlib.gzip(data, cacheRes);
				} else if(encoding == 'deflate') {
					zlib.deflate(data, cacheRes);
				} else {
					cacheRes(null, data);
				}
			}
		
			if(data) {
				compressRespond(data);
			} else {
				var filePath = self._urlToPath(req.url);
				fs.readFile(filePath, function(err, data) {
					if(err) {
						if(err.code == 'ENOENT') {
							res.writeHead(404);
							res.end('Resource ' + req.url + ' could not be found');
						} else {
							res.writeHead(500);
							res.end('Could not access ' + req.url);
						}
					} else {
						var ext = filePath.match(self._extRegex);
						ext = ext ? ext[0] : '';
						
						self._setFileResponseHeaders(res, filePath);
						if(ext == '.less') {
							if(req.params.ck) {
								data = data.toString();
							} else {
								data = self._versionDeepCSSURLs(data.toString());
							}
							less.render(data, function (e, css) {
								compressRespond(data);
							});
						} else {
							if(ext == '.css') {
								if(req.params.ck) {
									data = data.toString();
								} else {
									data = self._versionDeepCSSURLs(data.toString());
								}
							}
							compressRespond(data);
						}
					}
				});
			}
		}
	}
	
	self._urlToPath = function(url) {
		url = url.replace(/\?.*/, '');
		return path.normalize(self._rootDirPath + url);
	}
	
	self._setFileResponseHeaders = function(res, filePath) {	
		var mimeType = mime.lookup(filePath);
		
		if(self._releaseMode) {
			var now = new Date();
			var oneMonth = new Date(now.getTime() + self._cacheLife);
			
			res.setHeader('Cache-Control', self._cacheType);
			res.setHeader('Pragma', self._cacheType);
			res.setHeader('Expires', oneMonth.toUTCString());
		} else {
			res.setHeader('Pragma', 'no-cache');
			res.setHeader('Cache-Control', 'no-cache, must-revalidate');
		}
		res.setHeader('Content-Type', mimeType);
	}
	
	self.getOptions = function() {
		return self._options;
	}
	
	self.start = function(options) {
		if(options) {
			self._options = options;
			self._releaseMode = self._options.release ? true : false;
			
			if(self._releaseMode) {
				self._cacheVersionManager = new SmartCacheManager(self._options.cacheVersion);
				
				if(self._options.autoMinify && self._options.minifyURLs) {
					var i, j, url, dir, files, filePath, curFile, data, ext, ast, ugly, stat;
					for(i in self._options.minifyURLs) {
						url = self._options.minifyURLs[i];
						filePath = self._urlToPath(url);
						stat = fs.statSync(filePath);
						if(stat.isDirectory()) {
							files = wrench.readdirSyncRecursive(filePath);
							for(j in files) {
								curFile = filePath + files[j];
								ext = curFile.match(self._extRegex);
								ext = ext ? ext[0] : '';
								if(ext == '.js') {
									data = fs.readFileSync(curFile);
									ast = jsp.parse(data.toString());
									ast = pro.ast_mangle(ast);
									ast = pro.ast_squeeze(ast);
									ugly = pro.gen_code(ast);
									
									cache.setFile(curFile, ugly);
								}
							}
						} else if(stat.isFile()) {
							data = fs.readFileSync(filePath);
							ast = jsp.parse(data.toString());
							ast = pro.ast_mangle(ast);
							ast = pro.ast_squeeze(ast);
							ugly = pro.gen_code(ast);
							
							cache.setFile(filePath, ugly);
						}
					}
				}
			}
			
			if(self._options.cacheLife) {
				self._cacheLife = self._options.cacheLife;
			}
			if(self._options.cacheType) {
				self._cacheType = self._options.cacheType;
			}
			if(self._options.protocol) {
				self._protocol = self._options.protocol;
			}
			if(self._options.privateExtensionRegex) {
				self._privateExtension = self._options.privateExtensionRegex;
			}
			if(self._options.rootDirPath) {
				self._rootDirPath = self._options.rootDirPath;
			}
		}
	}
	self._versionDeepCSSURLs = function(content) {
		if(self._releaseMode) {
			content = content.replace(/@import +["']([^"']+)["']/g, function(match, first) {
				return '@import "' + self._cacheVersionManager.setURLCacheVersion(first) + '"';
			});
			
			content = content.replace(/([^A-Za-z0-9]|^)url[(][ ]*["']?([^"')]*)["']?[ ]*[)]/g, function(match, first, second) {
				return first + 'url("' + self._cacheVersionManager.setURLCacheVersion(second) + '")';
			});
		}
		return content;
	}
	
	self.rout = function(req, res) {
		var filePath = self._urlToPath(req.url);
		var acceptEncoding = req.headers['accept-encoding'] || '';
		
		var encoding;
		if(acceptEncoding.match(/\bgzip\b/)) {
			encoding = 'gzip';
		} else if(acceptEncoding.match(/\bdeflate\b/)) {
			encoding = 'deflate';
		} else {
			encoding = '';
		}
		
		var cacheKey;
		if(encoding.length > 0) {
			cacheKey = encoding + ':' + filePath;
		} else {
			cacheKey = filePath;
		}
		
		if(self._privateExtension && self._privateExtension.test(req.url)) {
			res.writeHead(403);
			res.end('Request ' + req.url + ' refers to a private resource which cannot be accessed directly');
		} else {
			if(self._releaseMode && cache.hasFile(cacheKey)) {
				self._setFileResponseHeaders(res, filePath);
				self.respond(req, res, cacheKey, null, encoding);
			} else if(self._releaseMode && cache.hasFile(filePath)) {
				self._setFileResponseHeaders(res, filePath);
				self.respond(req, res, cacheKey, cache.getFile(filePath), encoding);
			} else {
				fs.readFile(filePath, function(err, data) {
					if(err) {
						if(err.code == 'ENOENT') {
							res.writeHead(404);
							res.end('Resource ' + req.url + ' could not be found');
						} else {
							res.writeHead(500);
							res.end('Could not access ' + req.url);
						}
					} else {
						var ext = filePath.match(self._extRegex);
						ext = ext ? ext[0] : '';
						
						self._setFileResponseHeaders(res, filePath);
						
						if(ext == '.less') {
							if(req.params.ck) {
								data = data.toString();
							} else {
								data = self._versionDeepCSSURLs(data.toString());
							}
							less.render(data, function (e, css) {
								self.respond(req, res, cacheKey, css, encoding);
							});
						} else {
							if(ext == '.css') {
								if(req.params.ck) {
									data = data.toString();
								} else {
									data = self._versionDeepCSSURLs(data.toString());
								}
							}
							self.respond(req, res, cacheKey, data, encoding);
						}
					}
				});
			}
		}
	}
	
	self._redirect = function(req, res, url) {
		res.writeHead(301, {'Location': self._protocol + '://' + req.headers.host + url});
		res.end();
	}
})();

module.exports = Router;
