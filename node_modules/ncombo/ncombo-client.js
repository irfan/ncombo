/**
	This script provides the core javascript functionality of nCombo.
*/
var $n = {
	MAX_ID: Math.pow(2, 53) - 2,
	_appURL: null,
	_callCount: 0,
	_callTracker: {},
	_frameworkURL: null,
	_jsLibsURL: null,
	_frameworkStylesURL: null,
	_scriptsRouterURL: null,
	_appScriptsURL: null,
	_appStylesURL: null,
	_appAssetsURL: null,
	_appFilesURL: null,
	_appTemplatesURL: null,
	_cacheSeverCalls: false,
	_wsEndpoint: null,
	_wsSocket: null,
	_callbacks: {},
	_mainNamespace: null,
	_namespaces: {},
    
	init: function(appDefinition) {
		$n._frameworkURL = appDefinition.frameworkURL;
		$n._appURL = appDefinition.appURL;
		$n._jsLibsURL = appDefinition.jsLibsURL;
		$n._frameworkStylesURL = appDefinition.frameworkStylesURL;
		$n._scriptsRouterURL = location.href.replace(/\?.*/, '');
		$n._appScriptsURL = appDefinition.appScriptsURL;
		$n._appStylesURL = appDefinition.appStylesURL;
		$n._appTemplatesURL = appDefinition.appTemplatesURL;
		$n._appAssetsURL = appDefinition.appAssetsURL;
		$n._appFilesURL = appDefinition.appFilesURL;
		$n._wsEndpoint = appDefinition.wsEndpoint;
		
		$n._wsSocket = NCOMBO_SOCKET;

		$n._callbacks['ready'] = [];
		$n._callbacks['fail'] = [];
		
		$n._mainNamespace = $n.ns('__main');
		
		$n._wsSocket.on('return', $n._callReturn);
		$n._wsSocket.on('event', $n._eventReceived);
	},
	
	_genID: function() {
		$n._callCount++;
		$n._callCount = $n._callCount % $n.MAX_ID;
		return $n._callCount;
	},
	
	/**
		Convert a class (function) into a mixin-extendable class. This will give the class internal access to an
		initMixin(mixinClass, args) method and a callMixinMethod(mixinClass, method, args) which will allow the current
		class to manipulate base mixins.
	*/
	mixin: function(mainClass) {
		var mixinHolder = function() {
			this._internalMixinArgs = {};
			
			this.initMixin = function(mixinClass, args) {
				if(args && !(args instanceof Array)) {
					throw 'Exception: The args parameter of the initMixin function must be an Array';
				}
				this._internalMixinArgs[mixinClass] = args;
				
				if(args) {
					mixinClass.apply(this, args);
				} else {
					mixinClass.apply(this);
				}
			}
			
			this.callMixinMethod = function(mixinClass, method, args) {
				if(args && !(args instanceof Array)) {
					throw 'Exception: The args parameter of the callMixinMethod function must be an Array';
				}
				var mixedIn = new mixinClass(this._internalMixinArgs[mixinClass]);
				var methodToCall = mixedIn[method];
				
				var value, index;
				for(index in this) {
					value = this[index];
					if((!(value instanceof Function) || !(mixedIn[index] instanceof Function) || mixedIn[index].toString() != value.toString())) {
						mixedIn[index] = value;
					}
				}
				var result = methodToCall.apply(mixedIn, args);
				delete mixedIn;
				
				return result;
			}
			
			this.instanceOf = function(classReference) {
				return this instanceof classReference || this._internalMixinArgs.hasOwnProperty(classReference);
			}
		}
		mixinHolder.apply(mainClass.prototype);
		
		return mainClass;
	},
	
	getBasicType: function(variable) {
		var classType = {}.toString
		var typeRegex = /[^0-9A-Za-z]*([A-Z][a-zA-Z0-9]*)/;
		var typeString = classType.call(variable);
		return typeString.match(typeRegex)[1];
	},
	
	/**
		Bind a callback function to nCombo's ready event. The specified function will be called when nCombo is ready to begin processing.
	*/
	ready: function(callback) {
		if(!$n.grab.isGrabbing()) {
			callback();
		} else {
			$n._callbacks['ready'].push(callback);
		}
	},
	
	/**
		Bind a callback function to nCombo's fail event. The specified function will be called when nCombo fails to load a resource.
		The callback can accept a parameter which indicates the URL of the resource which failed to load.
	*/
	fail: function(callback) {
		$n._callbacks['fail'].push(callback);
	},
	
	EventDispatcher: function() {
		var self = this;
		self._listeners = {};
		
		self.on = function(event, listener) {
			if(!self._listeners.hasOwnProperty(event)) {
				self._listeners[event] = {};
			}
			self._listeners[event][listener] = listener;
		}
		
		self.off = function(event, listener) {
			return self._listeners.hasOwnProperty(event) && self._listeners[event].hasOwnProperty(listener);
		}
		
		self.removeEventListener = function(event, listener) {
			if(self.willTrigger(event, listener)) {
				delete self._listeners[event][listener];
			}
		}
		
		self.dispatchEvent = function(event, eventData) {
			if(self._listeners.hasOwnProperty(event)) {
				var eventListeners = self._listeners[event];
				var i;
				for(i in eventListeners) {
					eventListeners[i](eventData);
				}
			}
		}
		
		self.numListeners = function(event) {
			if(self._listeners[event]) {
				var count = 0;
				var i;
				for(i in self._listeners[event]) {
					count++;
				}
				return count;
			}
			return 0;
		}
	},
	
	_triggerReady: function() {
		var callbacks = $n._callbacks['ready'];
		$n._callbacks['ready'] = [];
		if(callbacks.length > 0) {
			$n._execReadyCallbacks(callbacks);
		}
	},
	
	_execReadyCallbacks: function(callbacks) {
		var len = callbacks.length;
		var i;
		
		for(i=len-1; i>=0; i--) {
			callbacks[i]();
		}
	},
	
	_triggerFail: function(url) {
		var len = $n._callbacks['fail'].length;
		var i;
		for(i=0; i<len; i++) {
			 $n._callbacks['fail'][i](url);
		}
	},
	
	/**
		This object holds error functions to handle various client-side error types that can occur within the system.
		Each function handles a specific type of error and can accept any suitable number of parameters
		in order to generate the appropriate error message.
	*/
	errors: {	
		loadTemplateError: function(message) {
			return "LoadTemplateError: Could not load one or more templates because of the following AJAX error: " + message;
		},
		
		serverInterfaceError: function(message) {
			return "ServerInterfaceError: " + message;
		},
		
		loadError: function(resourceURL) {
			return "LoadError: Failed to load resource: " + resourceURL;
		}
	},
	
	/**
		Get the URL of nCombo's root directory.
	*/
	getRootURL: function() {
		return $n._frameworkURL;
	},
	
	/**
		Navigate to another script.
	*/
	navigateToScript: function(scriptName) {
		location.href = $n._scriptsRouterURL + (scriptName ? "?" + scriptName : "");
	},
	
	caching: {
		/**
			Enable/disable default caching for server interface AJAX calls performed by nCombo.
			Server call caching is disabled by default.
		*/
		cacheServerCalls: function(bool) {
			$n._cacheSeverCalls = bool;
		}
	},
	
	res: {
		_templates: {},
		
		template: function(name) {
			if(!$n.res.hasTemplate(name)) {
				throw 'Exception: The ' + name + ' template is not available';
			}
			return $n.res._templates[name].clone();
		},
		
		hasTemplate: function(name) {
			return $n.res._templates.hasOwnProperty(name);
		},
		
		addTemplate: function(name, template) {
			$n.res._templates[name] = template;
		},
		
		removeTemplate: function() {
			if($n.res._templates.hasOwnProperty(name)) {
				delete $n.res._templates[name];
			}
		}
	},
	
	/**
		Grab allows you to include external scripts, CSS stylesheets and templates into your JavaScript.
		Some grab methods allow you to load resources either synchronously or asynchronously.
	*/
	grab: {
		_activeScripts: new Object(),
		_activeCSS: new Object(),
		_loadedTemplates: new Object(),
		_resources: [],
		_resourcesLoaded: [],
		_resourcesGrabbed: [],
		_deepResources: [],
		_deepResourcesLoaded: [],
		_resourcesLoadedMap: {},
		_deepResources: {},
		_deepResourcesLoaded: {},
		_embedQueue: [],
		_extRegex: /[.][^\/\\]*$/,
		_lessExtRegex: /[.]less$/,
		
		/**
			Include a script from the application's script directory into the current script.
		*/
		script: function(name, successCallback, errorCallback) {
			if($n.grab._extRegex.test(name)) {
				var resourceName = $n._appScriptsURL + name;
			} else {
				var resourceName = $n._appScriptsURL + name + '.js';
			}
			if(!$n.grab._activeScripts[resourceName]) {
				$n.grab.loadAndEmbedScript(resourceName, successCallback, errorCallback);
				$n.grab._activeScripts[resourceName] = true;
			}
		},
		
		/**
			Include a script from nCombo's javascript library directory into the current script.
		*/
		lib: function(name, successCallback, errorCallback) {
			if($n.grab._extRegex.test(name)) {
				var resourceName = $n._jsLibsURL + name;
			} else {
				var resourceName = $n._jsLibsURL + name + '.js';
			}
			if(!$n.grab._activeScripts[resourceName]) {
				$n.grab.loadAndEmbedScript(resourceName, successCallback, errorCallback);
				$n.grab._activeScripts[resourceName] = true;
			}
		},
		
		/**
			Include a script from a given URL.
		*/
		remoteScript: function(url, successCallback, errorCallback) {
			var resourceName = url;
			if(!$n.grab._activeScripts[resourceName]) {
				$n.grab.loadAndEmbedScript(resourceName, successCallback, errorCallback);
				$n.grab._activeScripts[resourceName] = true;
			}
		},
		
		/**
			Include an application CSS stylesheet (from the application directory) into the application.
		*/
		appCSS: function(name, successCallback, errorCallback) {
			if($n.grab._extRegex.test(name)) {
				var resourceName = $n._appStylesURL + name;
			} else {
				var resourceName = $n._appStylesURL + name + '.css';
			}
			if(!$n.grab._activeCSS[resourceName]) {
				$n.grab.loadAndEmbedCSS(resourceName, successCallback, errorCallback);
				$n.grab._activeCSS[resourceName] = true;
			}
		},
		
		/**
			Include a default framework CSS stylesheet (from the ncombo framework directory) into the application.
		*/
		frameworkCSS: function(name, successCallback, errorCallback) {
			if($n.grab._extRegex.test(name)) {
				var resourceName = $n._frameworkStylesURL + name;
			} else {
				var resourceName = $n._frameworkStylesURL + name + '.css';
			}
			if(!$n.grab._activeCSS[resourceName]) {
				$n.grab.loadAndEmbedCSS(resourceName, successCallback, errorCallback);
				$n.grab._activeCSS[resourceName] = true;
			}
		},
		
		/**
			Get the the image at the given URL and start downloading it.
		*/
		image: function(url, callback) {
			var img = new Image();
			if(callback) {
				img.onload = function() {
					callback(url);
				}
			}
			
			img.src = url;
			return img;
		},
		
		/**
			Grab the URL of an asset from the application's assets folder. A file extension must be appended to the file name.
		*/
		assetURL: function(nameWithExtension) {
			return $n._appAssetsURL + nameWithExtension;
		},
		
		/**
			Grab the URL of a file from the application's file folder. A file extension must be appended to the file name.
		*/
		fileURL: function(nameWithExtension) {
			return $n._appFilesURL + nameWithExtension;
		},
		
		template: function(name, fromFrameworkDir) {
			if($n.res.hasTemplate(name)) {
				return $n.res.template(name);
			}
			
			if(fromFrameworkDir) {
				var tmplDirURL = $n._frameworkURL + 'templates/';
			} else {
				var tmplDirURL = $n._appTemplatesURL;
			}
			
			var templ = new $n.Template();
			templ.grab(name, tmplDirURL);
			
			return templ;
		},
		
		_processEmbedQueue: function() {
			var curTag;
			while($n.grab._embedQueue.length > 0) {
				curTag = $n.grab._embedQueue[0];
				if(curTag.ready) {
					if(curTag.type == 'link') {
						$n.grab.linkTag(curTag.url, 'text/css', 'stylesheet');
						$n.grab._resourcesGrabbed.push(curTag.url);
						if(curTag.successCallback) {
							curTag.successCallback(curTag.url);
						}
						if(!$n.grab.isGrabbing()) {
							$n._triggerReady();
						}
						
					} else if(curTag.type == 'script') {
						$n.grab.scriptTag(curTag.url, 'text/javascript', null, function() {
							$n.grab._resourcesGrabbed.push(curTag.url);
							if(curTag.successCallback) {
								curTag.successCallback(url);
							}
							if(!$n.grab.isGrabbing()) {
								$n._triggerReady();
							}
						});
					}
					$n.grab._embedQueue.shift();
				} else {
					break;
				}
			}
		},
		
		loadAndEmbedScript: function(url, successCallback, errorCallback) {
			var tagData = {type: 'script', url: url, successCallback: successCallback, ready: false};
			$n.grab._embedQueue.push(tagData);
			$n.grab._loadDeepResourceToCache(url, function() {
				tagData.ready = true;
				$n.grab._processEmbedQueue();
			}, errorCallback);
		},
		
		loadAndEmbedCSS: function(url, successCallback, errorCallback) {
			var tagData = {type: 'link', url: url, successCallback: successCallback, ready: false}
			$n.grab._embedQueue.push(tagData);
			$n.grab._loadDeepResourceToCache(url, function() {
				tagData.ready = true;
				$n.grab._processEmbedQueue();
			}, errorCallback);
		},
		
		/**
			Insert a script tag into the current document as it is being constructed.
			The id & callback parameters are optional.
		*/
		scriptTag: function(url, type, id, callback) {		
			var head = document.getElementsByTagName('head')[0];
			var initScript = document.getElementById('jComboInitScript');
		
			var script = document.createElement('script');
			
			if(!$.browser.msie || parseInt($.browser.version) > 8) {
				script.onload = function() {callback(url);};
			} else {
				script.onreadystatechange = function() {
					if(this.readyState == 'complete' || this.readyState == 'loaded') {
						script.onreadystatechange = null;
						callback(url);
					}
				};
			}
			
			if(id) {
				script.id = id;
			}
			script.type = type;
			script.src = url;
			
			head.insertBefore(script, initScript);
		},
		
		/** 
			Insert a link tag into the current document as it is being constructed.
			The id & callback parameters are optional.
		*/
		linkTag: function(url, type, rel, id) {
			var head = document.getElementsByTagName('head')[0];
			
			var curScripts = document.getElementsByTagName('script');
			var firstScript = null;
			var firstIndex = 0;
			
			if(curScripts) {
				var len = curScripts.length;
				while(firstIndex < len && curScripts[firstIndex].parentNode != head) {
					firstIndex++;
				}
				if(firstIndex < len) {
					firstScript = curScripts[firstIndex];
				}
			}
			
			var link = document.createElement('link');
			
			if(id) {
				link.id = id;
			}
			link.rel = rel;
			link.type = type;
			link.href = url;
			
			if(firstScript) {
				head.insertBefore(link, firstScript);
			} else {
				var curLinks = document.getElementsByTagName('link');
				var lastLink = null;
				var lastIndex = curLinks.length - 1;
				if(curLinks) {
					while(lastIndex >= 0 && curLinks[lastIndex].parentNode != head) {
						lastIndex--;
					}
					if(lastIndex >= 0) {
						lastLink = curLinks[lastIndex];
					}
				}
				
				if(lastLink) {
					if(lastLink.nextSibling) {
						head.insertBefore(link, lastLink.nextSibling);
					} else {
						head.appendChild(link);
					}
				} else {
					head.appendChild(link);
				}
			}
		},
		
		isGrabbing: function() {
			return $n.grab._resourcesGrabbed.length < $n.grab._resources.length;
		},
		
		_loadDeepResourceToCache: function(url, successCallback, errorCallback, rootURL) {
			if(!$n.grab._resourcesLoadedMap[url]) {
				var resourceData = null;
				
				if(!rootURL || url == rootURL) {
					rootURL = url;
					$n.grab._resources.push(url);
					$n.grab._deepResources[rootURL] = [];
					$n.grab._deepResources[rootURL].push(url);
					
					$n.grab._deepResourcesLoaded[rootURL] = [];
				}
				
				if(/[.](png|jpg|gif)$/.test(url)) {
					// images
					var img = new Image();
					img.onload = function() {
						if(url == rootURL) {
							resourceData = img;
						}	
						$n.grab._resourcesLoadedMap[url] = true;
						$n.grab._deepResourcesLoaded[rootURL].push(url);
						
						if($n.grab._deepResourcesLoaded[rootURL].length >= $n.grab._deepResources[rootURL].length) {
							$n.grab._resourcesLoaded.push(rootURL);
							if(successCallback) {
								successCallback(rootURL, resourceData);
							}
						}
					};
					
					img.onerror = function() {
						$n._triggerFail(url);
						if(errorCallback) {
							errorCallback(url);
						}
					};
					
					img.src = url;
				} else {
					// all text-based files
					$.ajax({
						url: url,
						type: "GET",
						dataType: "html",
						cache: true,
						async: true,
						success: function(data) {
							if(url == rootURL) {
								resourceData = data;
							}
							
							$n.grab._resourcesLoadedMap[url] = true;
							$n.grab._deepResourcesLoaded[rootURL].push(url);
							var urls, nonLoadedURLs;
							if(/[.](css|less)$/.test(url)) {
								nonLoadedURLs = [];
								urls = $n.grab._parseDeepCSSURLs(data, url);
								
								var i, curURL;
								var len = urls.length;
								for(i=0; i<len; i++) {
									curURL = urls[i];
									
									if(!$n.grab._resourcesLoadedMap[curURL]) {
										$n.grab._deepResources[rootURL].push(curURL);
										nonLoadedURLs.push(curURL);
									}
								}
								
								len = nonLoadedURLs.length;
								
								for(i=0; i<len; i++) {
									$n.grab._loadDeepResourceToCache(nonLoadedURLs[i], successCallback, errorCallback, rootURL);
								}
							}
							
							if($n.grab._deepResourcesLoaded[rootURL].length >= $n.grab._deepResources[rootURL].length) {
								$n.grab._resourcesLoaded.push(rootURL);
								if(successCallback) {
									successCallback(rootURL, resourceData);
								}
							}
						},
						
						error: function() {
							$n._triggerFail(url);
							if(errorCallback) {
								errorCallback(url);
							}
						}
					});
				}
			}
		},
		
		_parseDeepCSSURLs: function(fileContent, fileURL) {
			var urlMap = {};
			var urls = [];
			var fileDirURL = fileURL.match(/^(.*)\//)[0];
			
			var chuncks = $n.grab._parseFunctionCalls(fileContent, ['url']);
			
			var imports = fileContent.match(/@import +["'][^"']+["']/g);
			if(imports) {
				chuncks = chuncks.concat(imports);
			}
			
			var isolateURL = /(^url[(][ ]*"?|"?[)]$|^@import[ ]*["']|"$)/g;
			var absolute = /^https?:[/][/]/;
			
			var i, curURL;
			var len = chuncks.length;
			for(i=0; i<len; i++) {
				curURL = chuncks[i].replace(isolateURL, '');
				if(curURL != "" && !urlMap.hasOwnProperty(curURL)) {
					if(!absolute.test(curURL)) {
						urls.push(fileDirURL + curURL);
					} else {
						urls.push(curURL);
					}
					urlMap[curURL] = true;
				}
			}
				
			return urls;
		},
		
		_parseFunctionCalls: function(string, functionNames) {
			var functionCalls = [];
			var functionsRegex = new RegExp('(([^A-Za-z0-9]|^)' + functionNames.join(' *[(]|([^A-Za-z0-9]|^)') + ' *[(])', 'gm');
			var startPos = 0;
			var i, ch, len, curFunc, bt;
			while(true) {
				startPos = string.search(functionsRegex);
				if(startPos < 0) {
					break;
				}
				
				if(string.charAt(startPos) == '(') {
					startPos++;
				}
				
				curFunc = '';
				len = string.length;
				bt = 0;
				for(i=startPos; i<len; i++) {
					ch = string.charAt(i);
					curFunc += ch;
					
					if(ch == '(') {
						bt++;
					} else if(ch == ')') {
						if(--bt == 0) {
							functionCalls.push(curFunc.replace(/^[^A-Za-z0-9]/, ''));
							break;
						}
					}
				}
				string = string.substr(startPos + 2);
			}
			return functionCalls;
		}
	},
	
	serverInterfaceDescription: {},
	
	_callReturn: function(data) {
		var cid = data.cid;
		if($n._callTracker[cid]) {
			if(!data.noValue) {
				var finish = data.close ? true : false;
				if(!data.error) {
					if($n._callTracker[cid].success) {
						$n._callTracker[cid].success(data.value, finish);
					}
				} else if($n._callTracker[cid].error) {
					$n._callTracker[cid].error(data.value, finish);
				}
			}
			if(data.close) {
				delete $n._callTracker[cid];
			}
			if(data.error) {
				throw data.value;
			}
		}
	},
	
	_eventReceived: function(data) {
		$n.ns(data.namespace)._triggerWatchers(data.event, data.data);
	},
	
	acall: function(serverInterface, method, data, resultHandler, errorHandler) {
		var handler = null;
		
		if(resultHandler) {
			if(resultHandler.success) {
				handler = resultHandler;
			} else {
				handler = {success: resultHandler};
				if(errorHandler) {
					handler.error = errorHandler;
				}
			}
		}
		
		var cid = $n._genID();
		var request = {
			si: serverInterface,
			method: method,
			data: data,
			cid: cid
		};
		
		$n._callTracker[cid] = handler;
		
		$n._wsSocket.emit('sic', request);
	},
	
	ns: function(namespace) {
		if(!$n._namespaces[namespace]) {
			$n._namespaces[namespace] = new $n.NS(namespace, $n._wsSocket);
		}
		return $n._namespaces[namespace];
	},
	
	watch: function() {
		$n._mainNamespace.watch.apply(null, arguments);
	},
	
	unwatch: function() {
		$n._mainNamespace.unwatch.apply(null, arguments);
	},
	
	isWatching: function() {
		$n._mainNamespace.isWatching.apply(null, arguments);
	}
};

$n.NS = function(namespace, wsSocket) {
	var self = this;
	self._namespace = namespace;
	self._wsSocket = wsSocket;
	self._serverWatchMap = {};
	
	self.watch = function(event, handler) {
		if(!event || !handler) {
			throw "Exception: One or more required parameters were undefined";
		}
		
		if(!self._serverWatchMap.hasOwnProperty(event)) {
			self._serverWatchMap[event] = [];
		}
		
		self._serverWatchMap[event].push(handler);
		
		var request = {
			ns: self._namespace,
			event: event
		};
		
		self._wsSocket.emit('watch', request);
	}
	
	self.unwatch = function(event, handler) {
		var i, j;
		var unwatchRequests = [];
		
		if(!event) {
			for(j in self._serverWatchMap) {
				unwatchRequests.push({ns: self._namespace, event: j});
			}
			if(unwatchRequests.length > 0) {
				self._wsSocket.emit('unwatch', unwatchRequests);
			}
		} else if(!handler) {
			if(self._serverWatchMap[event]) {
				unwatchRequests.push({ns: self._namespace, event: event});
				delete self._serverWatchMap[event];
				if(unwatchRequests.length > 0) {
					self._wsSocket.emit('unwatch', unwatchRequests);
				}
			}
		} else {
			if(self._serverWatchMap[event]) {
				self._serverWatchMap[event] = $.grep(self._serverWatchMap[event], function(element, index) {
					if(element == handler) {
						unwatchRequests.push({ns: self._namespace, event: event});
						return false;
					}
					return true;
				});
				if(unwatchRequests.length > 0) {
					self._wsSocket.emit('unwatch', unwatchRequests);
				}
			}
		}
	}
	
	self._getWatcher = function(event, handler) {
		if(!event || !handler) {
			throw "Exception: One or more required parameters were undefined";
		}
		
		if(self._serverWatchMap[event]) {
			var watchers = self._serverWatchMap[event];
			var len = watchers.length;
			var i;
			for(i=0; i<len; i++) {
				if(watchers[i] == handler) {
					return watchers[i];
				}
			}
		}
		return null;
	}
	
	self.isWatching = function(event, handler) {
		return self._getWatcher(event, handler) ? true : false;
	}
	
	self._triggerWatchers = function(event, data) {
		if(self._serverWatchMap && self._serverWatchMap[event]) {
			var watchers = self._serverWatchMap[event];
			var len = watchers.length;
			var i;
			for(i=0; i<len; i++) {
				watchers[i].call(null, data);
			}
		}
	}
}

$n.Template = $n.mixin(function() {
	var self = this;
	self.initMixin($n.EventDispatcher);
	self._renderer = null;
	self._text = null;
	self._loaded = false;
	self._name = null;
	self._extRegex = /[.][^\/\\]*$/;
	
	self.getName = function() {
		return self._name;
	}
	
	self.grab = function(name, templateDirURL) {
		self._name = name;
		
		if(templateDirURL) {
			var tmplDirURL = templateDirURL;
		} else {
			var tmplDirURL = $n._appTemplatesURL;
		}
		
		if(self._extRegex.test(name)) {
			var url = tmplDirURL + name;
		} else {
			var url = tmplDirURL + name + '.handlebars';
		}
		
		$n.grab._loadDeepResourceToCache(url, function(url, data) {
			$n.grab._resourcesGrabbed.push(url);
			self._loaded = true;
			self._text = data;
			self._renderer = Handlebars.compile(self._text);
			
			$n.res.addTemplate(name, self);
			self.dispatchEvent('load', self);
			
			if(!$n.grab.isGrabbing()) {
				$n._triggerReady();
			}
		}, function() {
			self.dispatchEvent('error', self);
		});
	}
	
	self.make = function(name, content) {
		self._name = name;
		self._text = content;
		self._renderer = Handlebars.compile(self._text);
		self._loaded = true;
	}
	
	self.clone = function() {
		var templ = new $n.Template();
		templ.make(self._name, self._text);
		return templ;
	}
	
	self.on = function(event, listener) {
		if((event == 'load' || event == 'error') && self._loaded) {
			listener(self);
		} else {
			self.callMixinMethod($n.EventDispatcher, 'on', [event, listener]);
		}
	}
	
	self.load = function(listener)	{
		self.on('load', listener);
	}
	
	self.error = function(listener)	{
		self.on('error', listener);
	}
	
	self.render = function(data) {
		if(!self._loaded) {
			throw 'The template has not been loaded';
		}
		return self._renderer(data);
	}
	
	self.getText = function() {
		return self._text;
	}
	
	self.getRenderer = function() {
		return self._renderer;
	}
	
	self.isLoaded = function() {
		return self._loaded;
	}
});

if(!Array.prototype.indexOf) {
	Array.prototype.indexOf = function(item, start) {
		if(!start) {
			start = 0;
		}
		var len = this.length;
		var i;
		for(i=start; i<len; i++) {
			if(this[i] === item) {
				return i;
			}
		}
		return -1;
	}
}