var http = require('http'),
	https = require('https'),
	path = require('path'),
	mime = require('mime'),
	fs = require('fs'),
	Step = require('step'),
	io = require('../socket.io/lib/socket.io'),
	conf = require('ncombo/core/configmanager'),
	gateway = require('ncombo/core/gateway'),
	handlebars = require('./libs/handlebars'),
	cache = require('ncombo/core/cache');

var nCombo = new (function() {
	var self = this;
	self._refDir = 'node_modules/ncombo/';
	self._config = conf.parseConfig(__dirname + '/config.node.json');
	self._router = require(__dirname + '/' + self._config.router);
	self._prerouter = null;
	
	self._rootTemplate = self._config.rootTemplateURL;
	self._clientScriptMap = {};
	self._clientScripts = [];
	self._clientStyles = [];
	self._initializeCallbacks = [];
	self._wsEndpoint = null;
	self._extRegex = /[.][^\/\\]*$/;
	
	self._protocol = 'http';
	self._protocolOptions = {};
	
	self._cacheMode = false;
	self._rootDirPath = path.resolve(__dirname + '/../../');
	
	self._defaultScriptType = 'text/javascript';
	self._defaultStyleType = 'text/css';
	self._defaultStyleRel = 'stylesheet';
	
	self._server = null;
	self._io = null;
	self._prepareCallbacks = [];
	self._wsEndpoint = self._config.webServiceEndpoint;
	self._clientIncludes = self._config.clientIncludes;
	
	mime.define({
		'text/css': ['less'],
		'text/html': ['handlebars']
	});
	
	if(self._config.privateExtensionRegex) {
		self._privateExtensionRegex = new RegExp(self._config.privateExtensionRegex);
	} else {
		self._privateExtensionRegex = /$a/;
	}
	self._wsSocks = null;
	
	gateway.init(__dirname + '/' + self._config.serverInterfaceDir, self._privateExtensionRegex);
	
	self.useScript = function(pathFromRoot, type) {
		var normalPath = path.normalize(pathFromRoot);
		var obj = {};
		if(!self._clientScriptMap[normalPath]) {
			if(self._extRegex.test(pathFromRoot)) {
				obj['path'] = normalPath;
			} else {
				obj['path'] = pathFromRoot + '.js';
			}
			if(type) {
				obj['type'] = type;
			}
			self._clientScripts.push(obj);
			self._clientScriptMap[normalPath] = true;
		}
	}
	
	self.useStyle = function(pathFromRoot, type, rel) {
		var obj = {};
		if(self._extRegex.test(pathFromRoot)) {
			obj['path'] = pathFromRoot;
		} else {
			obj['path'] = pathFromRoot + '.css';
		}
		
		if(type) {
			obj['type'] = type;
		}
		if(rel) {
			obj['rel'] = rel;
		}
		self._clientStyles.push(obj);
	}
	
	self.useScript('node_modules/socket.io/node_modules/socket.io-client/dist/socket.io.min.js');
	self.useScript(self._refDir + 'libs/jquery.js');
	self.useScript(self._refDir + 'libs/handlebars.js');
	self.useScript(self._refDir + 'libs/json2.js');
	self.useScript(self._refDir + 'ncombo-client.js');
	self.useScript(self._refDir + 'core/init.js');
	
	var i, url;
	for(i in self._clientIncludes) {
		url = path.normalize(self._refDir + self._clientIncludes[i]);
		self.useScript(url);
	}
	
	self._setFileResponseHeaders = function(res, filePath) {	
		var mimeType = mime.lookup(filePath);
		
		if(self._cacheMode) {
			var now = new Date();
			var oneMonth = new Date(now.getTime() + 2592000000);
			
			res.setHeader('Cache-Control', 'public');
			res.setHeader('Pragma', 'public');
			res.setHeader('Expires', oneMonth.toUTCString());
		} else {
			res.setHeader('Cache-Control', 'no-cache');
			res.setHeader('Pragma', 'no-cache');
		}
		
		res.writeHead(200, {'Content-Type': mimeType});
	}
	
	self._urlToPath = function(url) {
		return self._rootDirPath + url;
	}
	
	self._handler = function(req, res) {
		if(/\/$/.test(req.url)) {
			req.url = self._rootTemplate;
		}
		
		if(req.url == self._rootTemplate) {
			var filePath = self._urlToPath(req.url);
			
			if(self._cacheMode && cache.hasFile(filePath)) {
				self._setFileResponseHeaders(res, filePath);
				if(!res.finished) {
					res.end(cache.getFile(filePath));
				}
			} else {
				fs.readFile(filePath, function(err, data) {
					if(err) {
						if(err.code == 'ENOENT') {
							res.writeHead(404);
							res.end('Root template could not be found at URL ' + req.url);
						} else {
							res.writeHead(500);
							res.end('Could not access root template at URL ' + req.url);
						}
					} else {
						self._setFileResponseHeaders(res, filePath);
						
						self._triggerInitialize(req, res);
						
						var includeString = '';
						
						includeString += self._getStyleTag({path: './node_modules/ncombo/styles/ncombo.css', type: 'text/css', rel: 'stylesheet'}, req) + "\n";
						includeString += self._getScriptTag({path: './node_modules/ncombo/loader.js', type: 'text/javascript'}, req);
						
						var frameworkURL = self._pathToURL('./node_modules/ncombo/', req);
						var routToScriptURL = self._pathToURL('./app/scripts/index.js', req);
						var loadScriptURL = self._pathToURL('./node_modules/ncombo/scripts/load.js', req);
						
						var appDef = {};
						appDef.frameworkURL = frameworkURL;
						appDef.jsLibsURL = self._pathToURL('./node_modules/ncombo/libs/', req);
						appDef.frameworkStylesURL = self._pathToURL('./node_modules/ncombo/styles/', req);
						appDef.appScriptsURL = self._pathToURL('./app/scripts/', req);
						appDef.appStylesURL = self._pathToURL('./app/styles/', req);
						appDef.appTemplatesURL = self._pathToURL('./app/templates/', req);
						appDef.appAssetsURL = self._pathToURL('./app/assets/', req);
						appDef.appFilesURL = self._pathToURL('./app/files/', req);
						appDef.wsEndpoint = self._wsEndpoint;
						
						var resources = [];
						var resourceProps = {};
						
						var len = self._clientStyles.length;
						var i, j, url, cur, count;
						for(i=0; i<len; i++) {
							cur = self._clientStyles[i];
							url = self._pathToURL(cur.path, req);
							resources.push(url);
							resourceProps[url] = {};
							count = 0;
							for(j in cur) {
								if(j != 'path') {
									resourceProps[url][j] = cur[j];
									count++;
								}
							}
							if(count == 0) {
								delete resourceProps[url];
							}
						}
						
						var len = self._clientScripts.length;
						for(i=0; i<len; i++) {
							cur = self._clientScripts[i];
							url = self._pathToURL(cur.path, req);
							resources.push(url);
							resourceProps[url] = {};
							count = 0;
							for(j in cur) {
								if(j != 'path') {
									resourceProps[url][j] = cur[j];
									count++;
								}
							}
							if(count == 0) {
								delete resourceProps[url];
							}
						}
						
						var resString = JSON.stringify(resources);
						var resPropString = JSON.stringify(resourceProps);
						
						var appString = JSON.stringify(appDef);
						
						var loaderCode = '$loader.init("' + frameworkURL + '","' + routToScriptURL + '","' +
								loadScriptURL + '",' + resString + ',' + resPropString + ',' + appString + ',false);';
						
						includeString += self._getScriptCodeTag(loaderCode);
						
						var template = handlebars.compile(data.toString());
						var html = template({includes: new handlebars.SafeString(includeString)});
						
						if(self._cacheMode) {
							cache.setFile(filePath, html);
						}
						
						res.end(html);
					}
				});
			}
		} else {
			Step(
				function() {
					if(self._prerouter) {
						if(!self._prerouter.rout) {
							throw 'Prerouter must implement a rout(req, res, stepCallback(req, res)) method';
						}
						self._prerouter.rout(req, res, this.parallel());
					} else {
						this(req, res);
					}
				}, 
				function(request, response) {
					if(request && response && !response.finished) {
						self._router.rout(request, response);
					}
				}
			);
		}
	}
	
	self._pathToURL = function(pathFromRoot, req) {
		var host = req.headers.host;
		
		var url = self._protocol + '://' + (path.normalize(host + '/' + pathFromRoot)).replace(/\\/g, '/');
		return url;
	}
	
	self._getScriptCodeTag = function(code, type) {
		if(!type) {
			type = self._defaultScriptType;
		}
		return '<script type="' + type + '">' + code + '</script>';
	}
	
	self._getScriptTag = function(scriptDefObject, req) {
		var url = self._pathToURL(scriptDefObject.path, req);
		return '<script type="' + scriptDefObject.type + '" src="' + url + '"></script>';
	}
	
	self._getStyleTag = function(scriptDefObject, req) {
		var url = self._pathToURL(scriptDefObject.path, req);
		rel = scriptDefObject.rel;
		if(!rel) {
			rel = self._defaultStyleRel;
		}
		return '<link rel="' + rel + '" type="' + scriptDefObject.type + '" href="' + url + '" />';
	}
	
	self.start = function(port, options) {
		var release = false;
		var logLevel = 1;
		
		if(options) {
			release = options.release ? true : false;
			if(options.protocol) {
				self._protocol = options.protocol;
			}
			self._protocolOptions = options.protocolOptions;
			
			if(options.logLevel) {
				logLevel = options.logLevel;
			}
			
			if(options.prerouter) {
				if(typeof options.prerouter == 'string') {
					self._prerouter = require(options.prerouter);
				} else {
					self._prerouter = options.prerouter;
				}
			}
		} else {
			options = {};
		}
		
		if(!options.protocol) {
			options.protocol = self._protocol;
		}
		if(!options.protocolOptions) {
			options.protocolOptions = self._protocolOptions;
		}
		options.rootDirPath = self._rootDirPath;
		
		if(self._prerouter) {
			if(!self._prerouter.start) {
				throw 'Prerouter must implement a start(options) method'
			}
			self._prerouter.start(options);
		}
		self._router.start(options);
		self._cacheMode = release;
		gateway.releaseMode(release);
		
		if(self._protocol == 'http') {
			self._server = http.createServer(self._handler);
		} else if(self._protocol == 'https') {
			if(self._protocolOptions) {
				self._server = https.createServer(self._protocolOptions, self._handler);
			} else {
				throw "The protocolOptions option must be set when https is used";
			}
		} else {
			throw "The " + self._protocol + " protocol is not supported";
		}
		
		self._io = io.listen(self._server);
		self._io.set('log level', logLevel);
		
		self._wsSocks = self._io.of(self._wsEndpoint);
		
		self._wsSocks.on('connection', function(socket) {
			socket.on('sic', function(request) {
				var siReq = new ServerInterfaceRequest(socket, request);
				self._triggerPrepare(siReq);
				gateway.call(request.si, request.method, request.data, siReq);
			});
			
			socket.on('watch', function(request) {
				gateway._watch(socket, request);
			});
			
			socket.on('unwatch', function(requests) {
				gateway._unwatch(socket, requests);
			});
			
			socket.on('disconnect', function() {
				gateway._unwatchAll(socket);
			});
		});
		
		self._server.listen(port);
		
		console.log('   nCombo server started on port ' + port);
	}
	
	self._triggerPrepare = function(siRequest) {
		var i;
		var len = self._prepareCallbacks.length;
		for(i=0; i<len; i++) {
			self._prepareCallbacks[i](siRequest);
		}
	}
	
	self.initialize = function(callback) {
		self._initializeCallbacks.push(callback);
	}
	
	self.uninitialize = function(callback) {
		var newList = [];
		var len = self._initializeCallbacks.length;
		var i;
		for(i=0; i<len; i++) {
			if(self._initializeCallbacks[i] != callback) {
				newList.push(self._initializeCallbacks[i]);
			}
		}
		self._initializeCallbacks = newList;
	}
	
	self._triggerInitialize = function(req, res) {
		var i;
		var len = self._initializeCallbacks.length;
		for(i=0; i<len; i++) {
			self._initializeCallbacks[i](req, res);
		}
	}
	
	self.prepare = function(callback) {
		self._prepareCallbacks.push(callback);
	}
	
	self.unprepare = function(callback) {
		var newList = [];
		var len = self._prepareCallbacks.length;
		var i;
		for(i=0; i<len; i++) {
			if(self._prepareCallbacks[i] != callback) {
				newList.push(self._prepareCallbacks[i]);
			}
		}
		self._prepareCallbacks = newList;
	}	
})();

var NS = function(namespace) {
	var self = this;
	self._namespace = namespace;
	
	self.broadcast = function(event, data) {
		if(!self._namespace || !event) {
			throw "Exception: One or more required parameters were undefined";
		}
		
		var eventObject = {namespace: self._namespace, event: event, data: data};
		var i;
		var watchers = gateway.getWatchers(self._namespace, event);
		
		for(i in watchers) {
			watchers[i].emit('event', eventObject);
		}
	}
}

var ServerInterfaceRequest = function(socket, request) {
	var self = this;
	self._open = true;
	self._socket = socket;
	self._request = request;
	self._mainNamespace = new NS('__main');
	self._namespaces = {'__main': self._mainNamespace};
	
	self._emitReturn = function(data) {
		if(self._open) {
			self._socket.emit('return', data);
		} else {
			throw "Exception: The current ServerInterfaceRequest has already been closed";
		}
		if(data.close) {
			self._open = false;
		}
	}
	
	self.send = function(data) {
		self._emitReturn({cid: self._request.cid, value: data});
	}
	
	self.respond = function(data) {
		self._emitReturn({cid: self._request.cid, value: data, close: 1});
	}
	
	self.error = function(data) {
		self._emitReturn({cid: self._request.cid, value: data, error: 1});
	}
	
	self.collapse = function(data) {
		self._emitReturn({cid: self._request.cid, value: data, error: 1, close: 1});
	}
	
	self.close = function() {
		self._emitReturn({cid: self._request.cid, close: 1, noValue: 1});
	}
	
	self.emit = function() {
		if(arguments.length < 2) {
			throw "Exception: One or more required parameters were undefined";
		}
		
		if(arguments.length > 2) {
			var namespace = arguments[0];
			var event = arguments[1];
			var data = arguments[2];
		} else {
			var namespace = '';
			var event = arguments[0];
			var data = arguments[1];
		}
		
		var eventObject = {namespace: namespace, event: event, data: data};
		self._socket.emit('event', eventObject);
	}
	
	self.set = function() {
		self._socket.set.apply(self._socket, arguments);
	}
	
	self.get = function() {
		self._socket.get.apply(self._socket, arguments);
	}
	
	self.ns = function(namespace) {
		if(!self._namespaces[namespace]) {
			self._namespaces[namespace] = new NS(namespace);
		}
		return self._namespaces[namespace];
	}
	
	self.broadcast = function() {
		self._mainNamespace.broadcast.apply(null, arguments);
	}
	
	self.getServerInterface = function() {
		return self._request.si;
	}
	
	self.getMethod = function() {
		return self._request.method;
	}
	
	self.getData = function() {
		return self._request.data;
	}
}

module.exports = nCombo;