var http = require('http'),
	https = require('https'),
	path = require('path'),
	mime = require('mime'),
	fs = require('fs'),
	io = require('../socket.io/lib/socket.io'),
	conf = require('ncombo/core/configmanager'),
	gateway = require('ncombo/core/gateway'),
	handlebars = require('./libs/handlebars'),
	cache = require('ncombo/core/cache'),
	stepper = require('stepper');

var SessionEmitter = function(namespace, socket) {
	var self = this;
	self._namespace = namespace;
	self._socket = socket;
	
	self.emit = function(event, data) {
		if(self._socket && gateway.hasWatcher(self._socket.id, self._namespace, event)) {
			var eventObject = {namespace: self._namespace, event: event, data: data};
			self._socket.emit('event', eventObject);
		}
	}
}

var ServerInterfaceRequest = function(socket, request, session, global) {
	var self = this;
	self.session = session;
	self.global = global;
	
	self._open = true;
	self._socket = socket;
	self._request = request;
	
	self._emitReturn = function(data) {
		if(self._open) {
			self._socket.emit('return', data);
		} else {
			throw "Exception: The current ServerInterfaceRequest has already been closed";
		}
		if(data.close) {
			self._open = false;
		}
	}
	
	self.send = function(data) {
		self._emitReturn({cid: self._request.cid, value: data});
	}
	
	self.end = function(data) {
		self._emitReturn({cid: self._request.cid, value: data, close: 1});
	}
	
	self.error = function(data) {
		self._emitReturn({cid: self._request.cid, value: data, error: 1});
	}
	
	self.collapse = function(data) {
		self._emitReturn({cid: self._request.cid, value: data, error: 1, close: 1});
	}
	
	self.close = function() {
		self._emitReturn({cid: self._request.cid, close: 1, noValue: 1});
	}
	
	self.getServerInterface = function() {
		return self._request.si;
	}
	
	self.getMethod = function() {
		return self._request.method;
	}
	
	self.getData = function() {
		return self._request.data;
	}
}

var GlobalEmitter = function(namespace, sessionMap) {
	var self = this;
	self._namespace = namespace;
	self._sessionMap = sessionMap;
	
	self.broadcast = function(event, data) {
		if(!self._namespace || !event) {
			throw "Exception: One or more required parameters were undefined";
		}
		
		var eventObject = {namespace: self._namespace, event: event, data: data};
		var i;
		var watchers = gateway.getWatchers(self._namespace, event);
		
		for(i in watchers) {
			watchers[i].emit('event', eventObject);
		}
	}
	
	self.emit = function(sessionID, event, data) {
		self._sessionMap[sessionID].ns(self._namespace).emit(event, data);
	}
	
	self.getSessionMap = function() {
		return self._sessionMap;
	}
	
	self.getSession = function(id) {
		return self._sessionMap[id];
	}
}

var Global = function(sessionMap) {
	var self = this;
	self._sessionMap = sessionMap;
	self._emitterNamespace = new GlobalEmitter('__main', self._sessionMap);
	self._namespaces = {'__main': self._emitterNamespace};
	
	self._data = {};
	
	self.emit = function(sessionID, event, data) {
		self._emitterNamespace.emit(sessionID, event, data);
	}
	
	self.broadcast = function(event, data) {
		self._emitterNamespace.broadcast(event, data);
	}
	
	self.getSessionMap = function() {
		return self._emitterNamespace.getSessionMap();
	}
	
	self.getSession = function(id) {
		return self._emitterNamespace.getSession(id);
	}
	
	self.ns = function(namespace) {
		if(!self._namespaces[namespace]) {
			self._namespaces[namespace] = new GlobalEmitter(namespace, self._sessionMap);
		}
		return self._namespaces[namespace];
	}
	
	self.get = function(key) {
		return self._data[key];
	}
	
	self.set = function(key, value) {
		self._data[key] = value;
	}
}

var nCombo = new (function() {
	var self = this;
	
	self._sessionMap = {};
	self._global = new Global(self._sessionMap);
	
	self._rootDirPath = path.resolve(__dirname + '/../../');
	self._refDir = 'node_modules/ncombo/';
	
	self._config = conf.parseConfig(__dirname + '/config.node.json');
	self._router = require(__dirname + '/' + self._config.router);
	self._fileUploader = require('ncombo/core/fileuploader');
	
	self._rootTemplateURL = self._config.rootTemplateURL;
	self._rootTemplateBody = fs.readFileSync(self._rootDirPath + self._rootTemplateURL, 'utf8');
	self._rootTemplate = handlebars.compile(self._rootTemplateBody);
	
	self._clientScriptMap = {};
	self._clientScripts = [];
	self._clientStyles = [];
	self._wsEndpoint = null;
	self._extRegex = /[.][^\/\\]*$/;
	
	self._wsEndpoint = self._config.webServiceEndpoint;
	
	self._protocol = 'http';
	self._protocolOptions = {};
	
	self._cacheMode = false;
	
	self._defaultScriptType = 'text/javascript';
	self._defaultStyleType = 'text/css';
	self._defaultStyleRel = 'stylesheet';
	
	self._server = null;
	self._io = null;
	self._prepareCallbacks = [];
	
	self._faviconHandler = function(req, res, next) {
		var iconPath = self._urlToPath('/app/assets/favicon.gif');
		
		if(req.url == '/favicon.ico') {
			fs.readFile(iconPath, function(err, data) {
				if(err) {
					if(err.code == 'ENOENT') {
						iconPath = self._urlToPath('/node_modules/ncombo/assets/favicon.gif');
						fs.readFile(iconPath, function(err, data) {
							if(err) {
								if(err.code == 'ENOENT') {
									res.writeHead(404);
									res.end();
								} else {
									res.writeHead(500);
									res.end();
								}
							} else {
								self._setFileResponseHeaders(res, iconPath);
								res.end(data);
							}
						});
					} else {
						res.writeHead(500);
						res.end();
					}
				} else {
					self._setFileResponseHeaders(res, iconPath);
					res.end(data);
				}
			});
		} else {
			next(req, res);
		}
	}
	
	self._getParamsHandler = function(req, res, next) {
		var paramString = req.url.match(/\?(.*)/);
		if(paramString) {
			var fieldsMap = {};
			var fields = paramString[1].split('&');
			var i, keyVal;
			for(i in fields) {
				keyVal = fields[i].split('=');
				fieldsMap[keyVal[0]] = keyVal[1];
			}
			
			req.url = req.url.replace(paramString[0], '');
			req.inputFields = fieldsMap;
		}
		
		next(req, res);
	}
	
	self._writeSessionStartScreen = function(req, res) {
		res.setHeader('Access-Control-Allow-Methods', 'OPTIONS, HEAD, GET, POST');
		res.setHeader('Access-Control-Allow-Origin', '*');
		res.setHeader('Cache-Control', 'no-cache, must-revalidate');
		res.setHeader('Pragma', 'no-cache');
		res.writeHead(200, {'Content-Type': 'text/html'});
		
		var includeString = self._getScriptTag({path: './node_modules/socket.io/node_modules/socket.io-client/dist/socket.io.min.js', 
				type: 'text/javascript'}, req) + "\n";
		
		includeString += self._getScriptTag({path: './node_modules/ncombo/core/session.js', 
				type: 'text/javascript'}, req);
		
		var html = self._rootTemplate({includes: new handlebars.SafeString(includeString)});
		
		res.end(html);
	}
	
	self._parseSID = function(cookieString) {
		if(cookieString) {
			var result = cookieString.match(/(sid=)([0-9]*)/);
			if(result) {
				return result[2]
			}
		}
		return null;
	}
	
	self._redirect = function(req, res, url) {
		res.writeHead(301, {'Location': self._protocol + '://' + req.headers.host + url});
		res.end();
	}
	
	self._getAppDef = function(frameworkURL, req) {
		var appDef = {};
		appDef.frameworkURL = frameworkURL;
		appDef.appURL = self._pathToURL('./app/', req);
		appDef.jsLibsURL = self._pathToURL('./node_modules/ncombo/libs/', req);
		appDef.frameworkStylesURL = self._pathToURL('./node_modules/ncombo/styles/', req);
		appDef.appScriptsURL = self._pathToURL('./app/scripts/', req);
		appDef.appStylesURL = self._pathToURL('./app/styles/', req);
		appDef.appTemplatesURL = self._pathToURL('./app/templates/', req);
		appDef.appAssetsURL = self._pathToURL('./app/assets/', req);
		appDef.appFilesURL = self._pathToURL('./app/files/', req);
		appDef.wsEndpoint = self._wsEndpoint;
		
		return appDef;
	}
	
	self._getLoaderCode = function(req) {
		var frameworkURL = self._pathToURL('./node_modules/ncombo/', req);
		var appDef = self._getAppDef(frameworkURL, req);
		var routToScriptURL = self._pathToURL('./app/scripts/index.js', req);
		var loadScriptURL = self._pathToURL('./node_modules/ncombo/scripts/load.js', req);
			
		var resources = [];
		var resourceProps = {};
		
		var len = self._clientStyles.length;
		var i, j, resURL, cur, count;
		for(i=0; i<len; i++) {
			cur = self._clientStyles[i];
			resURL = self._pathToURL(cur.path, req);
			resources.push(resURL);
			resourceProps[resURL] = {};
			count = 0;
			for(j in cur) {
				if(j != 'path') {
					resourceProps[resURL][j] = cur[j];
					count++;
				}
			}
			if(count == 0) {
				delete resourceProps[resURL];
			}
		}
		
		var len = self._clientScripts.length;
		for(i=0; i<len; i++) {
			cur = self._clientScripts[i];
			resURL = self._pathToURL(cur.path, req);
			resources.push(resURL);
			resourceProps[resURL] = {};
			count = 0;
			for(j in cur) {
				if(j != 'path') {
					resourceProps[resURL][j] = cur[j];
					count++;
				}
			}
			if(count == 0) {
				delete resourceProps[resURL];
			}
		}
		
		var resString = JSON.stringify(resources);
		var resPropString = JSON.stringify(resourceProps);
		
		var appString = JSON.stringify(appDef);
		
		var loaderCode = '$loader.init("' + frameworkURL + '","' + routToScriptURL + '","' +
				loadScriptURL + '",' + resString + ',' + resPropString + ',' + appString + ',' + (self._cacheMode ? 'false' : 'true') + ');';
		
		return loaderCode;
	}
	
	self._sessionHandler = function(req, res, next) {
		req.global = self._global;
		if(req.url == '/~startscript') {			
			var loaderCode = self._getLoaderCode(req);
			res.end(loaderCode);
		} else {
			var sid = self._parseSID(req.headers.cookie);
			
			var url;
			
			if(req.url == '/') {
				url = self._rootTemplateURL;
			} else {
				url = req.url;
			}
			
			var filePath = self._urlToPath(url);
			
			if(url == self._rootTemplateURL) {
				self._writeSessionStartScreen(req, res);
			} else {
				if(url == '/node_modules/ncombo/core/session.js' || url == '/node_modules/socket.io/node_modules/socket.io-client/dist/socket.io.min.js') {
					if(self._cacheMode && cache.hasFile(filePath)) {
						self._setFileResponseHeaders(res, filePath);
						if(!res.finished) {
							res.end(cache.getFile(filePath));
						}
					} else {
						fs.readFile(filePath, function(err, data) {
							if(err) {
								console.log(500, filePath);
								res.writeHead(500);
								res.end('Failed to start session');
							} else {
								self._setFileResponseHeaders(res, filePath);
								
								var template = handlebars.compile(data.toString());
								var js = template({endpoint: self._wsEndpoint});
								
								if(self._cacheMode) {
									cache.setFile(filePath, js);
								}
								
								res.end(js);
							}
						});
					}
				} else if(sid && self._sessionMap.hasOwnProperty(sid)) {
					req.session = self._sessionMap[sid];
					next(req, res);
				} else {
					self._redirect(req, res, '/');
				}
			}
		}
	}
	
	self._indexRouter = function(req, res, next) {
		var url;
		
		if(req.url == '/') {
			url = self._rootTemplateURL;
		} else {
			url = req.url;
		}
		if(url == self._rootTemplateURL) {
			var filePath = self._urlToPath(url);
			
			if(self._cacheMode && cache.hasFile(filePath)) {
				self._setFileResponseHeaders(res, filePath);
				if(!res.finished) {
					res.end(cache.getFile(filePath));
				}
			} else {
				fs.readFile(filePath, function(err, data) {
					if(err) {
						if(err.code == 'ENOENT') {
							res.writeHead(404);
							res.end('Root template could not be found at URL ' + url);
						} else {
							res.writeHead(500);
							res.end('Could not access root template at URL ' + url);
						}
					} else {
						self._setFileResponseHeaders(res, filePath);
						
						var includeString = self._getStyleTag({path: './node_modules/ncombo/styles/ncombo.css', type: 'text/css', rel: 'stylesheet'}, req) + "\n";
						includeString += self._getScriptTag({path: './node_modules/ncombo/loader.js', type: 'text/javascript'}, req);
						
						var loaderCode = self._getLoaderCode(req);
						
						includeString += self._getScriptCodeTag(loaderCode);
						
						var template = handlebars.compile(data.toString());
						var html = template({includes: new handlebars.SafeString(includeString)});
						
						if(self._cacheMode) {
							cache.setFile(filePath, html);
						}
						
						res.end(html);
					}
				});
			}
		} else {
			next(req, res);
		}
	}
	
	self._responseNotSentValidator = function(req, res) {
		return req && res && !res.finished;
	}
	
	self._middleware = {};
	
	self._backRoutStepper = stepper.create();
	self._backRoutStepper.addFunction(self._fileUploader.upload);
	self._backRoutStepper.setTail(self._router.rout);
	self._backRoutStepper.setValidator(self._responseNotSentValidator);
	
	self._middleware['router'] = stepper.create();
	self._middleware['router'].setTail(self._backRoutStepper);
	self._middleware['router'].setValidator(self._responseNotSentValidator);
	
	self._routStepper = stepper.create();
	self._routStepper.addFunction(self._faviconHandler);
	self._routStepper.addFunction(self._getParamsHandler); 
	self._routStepper.addFunction(self._sessionHandler);
	self._routStepper.addFunction(self._indexRouter);
	self._routStepper.setTail(self._middleware['router']);
	
	self._middleware['data'] = stepper.create();
	self._middleware['data'].setTail(gateway.call);
	
	self._clientIncludes = self._config.clientIncludes;
	
	mime.define({
		'text/css': ['less'],
		'text/html': ['handlebars']
	});
	
	if(self._config.privateExtensionRegex) {
		self._privateExtensionRegex = new RegExp(self._config.privateExtensionRegex);
	} else {
		self._privateExtensionRegex = /$a/;
	}
	self._wsSocks = null;
	
	gateway.init(__dirname + '/' + self._config.serverInterfaceDir, self._privateExtensionRegex);
	
	self.useScript = function(pathFromRoot, type) {
		var normalPath = path.normalize(pathFromRoot);
		var obj = {};
		if(!self._clientScriptMap[normalPath]) {
			if(self._extRegex.test(pathFromRoot)) {
				obj['path'] = normalPath;
			} else {
				obj['path'] = pathFromRoot + '.js';
			}
			if(type) {
				obj['type'] = type;
			}
			self._clientScripts.push(obj);
			self._clientScriptMap[normalPath] = true;
		}
	}
	
	self.useStyle = function(pathFromRoot, type, rel) {
		var obj = {};
		if(self._extRegex.test(pathFromRoot)) {
			obj['path'] = pathFromRoot;
		} else {
			obj['path'] = pathFromRoot + '.css';
		}
		
		if(type) {
			obj['type'] = type;
		}
		if(rel) {
			obj['rel'] = rel;
		}
		self._clientStyles.push(obj);
	}
	
	self.useScript(self._refDir + 'libs/jquery.js');
	self.useScript(self._refDir + 'libs/handlebars.js');
	self.useScript(self._refDir + 'libs/json2.js');
	
	self.useScript(self._refDir + 'ncombo-client.js');
	self.useScript(self._refDir + 'core/init.js');
	
	var i, url;
	for(i in self._clientIncludes) {
		url = path.normalize(self._refDir + self._clientIncludes[i]);
		self.useScript(url);
	}
	
	self._setFileResponseHeaders = function(res, filePath) {	
		var mimeType = mime.lookup(filePath);
		
		if(self._cacheMode) {
			var now = new Date();
			var oneMonth = new Date(now.getTime() + 2592000000);
			
			res.setHeader('Cache-Control', 'public');
			res.setHeader('Pragma', 'public');
			res.setHeader('Expires', oneMonth.toUTCString());
		} else {
			res.setHeader('Cache-Control', 'no-cache, must-revalidate');
			res.setHeader('Pragma', 'no-cache');
		}
		
		res.writeHead(200, {'Content-Type': mimeType});
	}
	
	self._urlToPath = function(url) {
		return self._rootDirPath + url;
	}
	
	self._pathToURL = function(pathFromRoot, req) {
		var host = req.headers.host;
		
		var url = self._protocol + '://' + (path.normalize(host + '/' + pathFromRoot)).replace(/\\/g, '/');
		return url;
	}
	
	self._getScriptCodeTag = function(code, type) {
		if(!type) {
			type = self._defaultScriptType;
		}
		return '<script type="' + type + '">' + code + '</script>';
	}
	
	self._getScriptTag = function(scriptDefObject, req) {
		var url = self._pathToURL(scriptDefObject.path, req);
		return '<script type="' + scriptDefObject.type + '" src="' + url + '"></script>';
	}
	
	self._getStyleTag = function(scriptDefObject, req) {
		var url = self._pathToURL(scriptDefObject.path, req);
		rel = scriptDefObject.rel;
		if(!rel) {
			rel = self._defaultStyleRel;
		}
		return '<link rel="' + rel + '" type="' + scriptDefObject.type + '" href="' + url + '" />';
	}
	
	self.start = function(port, options) {
		var release = false;
		var logLevel = 1;
		
		if(options) {
			release = options.release ? true : false;
			if(options.protocol) {
				self._protocol = options.protocol;
			}
			self._protocolOptions = options.protocolOptions;
			
			if(options.logLevel) {
				logLevel = options.logLevel;
			}
		} else {
			options = {};
		}
		
		if(!options.protocol) {
			options.protocol = self._protocol;
		}
		if(!options.protocolOptions) {
			options.protocolOptions = self._protocolOptions;
		}
		options.rootDirPath = self._rootDirPath;
		
		self._router.start(options);
		self._cacheMode = release;
		gateway.releaseMode(release);
		
		if(self._protocol == 'http') {
			self._server = http.createServer(self._routStepper.run);
		} else if(self._protocol == 'https') {
			if(self._protocolOptions) {
				self._server = https.createServer(self._protocolOptions, self._routStepper.run);
			} else {
				throw "The protocolOptions option must be set when https is used";
			}
		} else {
			throw "The " + self._protocol + " protocol is not supported";
		}
		
		self._io = io.listen(self._server);
		self._io.set('log level', logLevel);
		
		self._wsSocks = self._io.of(self._wsEndpoint);
		
		self._wsSocks.on('connection', function(socket) {
			
			socket.on('init', function() {
				self._sessionMap[socket.id] = new Session(socket.id, socket);
			});
			
			socket.on('sic', function(request) {
				var siReq = new ServerInterfaceRequest(socket, request, self._sessionMap[socket.id], self._global);
				
				self._middleware['data'].run(siReq);
			});
			
			socket.on('watch', function(request) {
				gateway._watch(socket, request);
			});
			
			socket.on('unwatch', function(requests) {
				gateway._unwatch(socket, requests);
			});
			
			socket.on('disconnect', function() {
				if(self._sessionMap.hasOwnProperty(socket.id)) {
					delete self._sessionMap[socket.id];
				}
				gateway._unwatchAll(socket);
			});
		});
		
		self._server.listen(port);
		
		console.log('   nCombo server started on port ' + port);
	}
	
	self.addMiddleware = function(type, callback) {
		if(!self._middleware.hasOwnProperty(type)) {
			console.log("Middleware type '" + type + "' is invalid");
		}
		
		self._middleware[type].addFunction(callback);
	}
	
	self.removeMiddleware = function(type, callback) {
		if(self._middleware[type].getLength() > 0) {
			self._middleware[type].remove(callback);
		}
	}
	
	self.addRouterMiddleware = function(callback) {
		self.addMiddleware('router', callback);
	}
	
	self.removeRouterMiddleware = function(callback) {
		self.removeMiddleware('router', callback);
	}
	
	self.addDataMiddleware = function(callback) {
		self.addMiddleware('data', callback);
	}
	
	self.removeDataMiddleware = function(callback) {
		self.removeMiddleware('data', callback);
	}
})();

var Session = function(sessionID, socket) {
	var self = this;
	self.id = sessionID;
	self._socket = socket;
	self._emitterNamespace = new SessionEmitter('__main', self._socket);
	self._namespaces = {'__main': self._emitterNamespace};
	
	self._data = {};
	
	self.emit = function(event, data) {
		self._emitterNamespace.emit(event, data);
	}
	
	self.ns = function(namespace) {
		if(!self._namespaces[namespace]) {
			self._namespaces[namespace] = new SessionEmitter(namespace, self._socket);
		}
		return self._namespaces[namespace];
	}
	
	self.get = function(key) {
		return self._data[key];
	}
	
	self.set = function(key, value) {
		self._data[key] = value;
	}
}

module.exports = nCombo;