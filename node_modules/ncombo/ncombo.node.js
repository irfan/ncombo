var http = require('http'),
	https = require('https'),
	path = require('path'),
	fs = require('fs'),
	io = require('../socket.io/lib/socket.io'),
	conf = require('ncombo/core/configmanager'),
	gateway = require('ncombo/core/gateway');

var nCombo = new (function() {
	var self = this;
	self._refDir = 'node_modules/ncombo/';
	self._config = conf.parseConfig(__dirname + '/config.node.json');
	self._router = require(__dirname + '/' + self._config.router);
	self._router.setRootTemplate(self._config.rootTemplateURL);
	
	self._server = null;
	self._io = null;
	self._prepareCallbacks = [];
	self._wsEndpoint = self._config.webServiceEndpoint;
	self._clientIncludes = self._config.clientIncludes;
	
	if(self._config.privateExtensionRegex) {
		self._privateExtensionRegex = new RegExp(self._config.privateExtensionRegex);
	} else {
		self._privateExtensionRegex = /$a/;
	}
	self._wsSocks = null;
	
	gateway.init(__dirname + '/' + self._config.serverInterfaceDir, self._privateExtensionRegex);
	
	self._router.includeClientScript('node_modules/socket.io/node_modules/socket.io-client/dist/socket.io.min.js');
	self._router.includeClientScript(self._refDir + 'libs/jquery.js');
	self._router.includeClientScript(self._refDir + 'libs/handlebars.js');
	self._router.includeClientScript(self._refDir + 'libs/json2.js');
	self._router.includeClientScript(self._refDir + 'ncombo-client.js');
	self._router.includeClientScript(self._refDir + 'core/init.js');
	
	var i, url;
	for(i in self._clientIncludes) {
		url = path.normalize(self._refDir + self._clientIncludes[i]);
		self._router.includeClientScript(url);
	}
	
	self._handler = function(req, res) {
		self._router.rout(req, res);
	}
	
	/*
		The following options are available:
		protocol: Can be either http or https (optional, default is http)
		protocolOptions: An options object to use when creating the https server (only required if protocol is https)
		rootDirectory: Set an alternate root directory for the application (optional)
	*/
	self.start = function(port, options) {
		var protocol, protocolOptions;
		var release = false;
		if(options) {
			release = options.release ? true : false;
			protocol = options.protocol;
			protocolOptions = options.protocolOptions;
			
			if(options.rootDirectory) {
				self._router.setRootDirectory(options.rootDirectory);
			}
		}
		self._router.setWSEndpoint(self._wsEndpoint);
		self._router.cacheResponses(release);
		gateway.releaseMode(release);
		
		if(!protocol) {
			protocol = 'http';
		}
		
		self._router.setProtocol(protocol);
		self._router.setPrivateExtensionRegex(self._privateExtensionRegex);
		
		if(protocol == 'http') {
			self._server = http.createServer(self._handler);
		} else if(protocol == 'https') {
			if(protocolOptions) {
				self._server = https.createServer(protocolOptions, self._handler);
			} else {
				throw "The protocolOptions option must be set when https is used";
			}
		} else {
			throw "The " + protocol + " protocol is not supported";
		}
		
		self._io = io.listen(self._server);
		self._io.set('log level', 1);
		
		self._wsSocks = self._io.of(self._wsEndpoint);
		
		self._wsSocks.on('connection', function(socket) {
			socket.on('sic', function(request) {
				var siReq = new ServerInterfaceRequest(socket, request);
				self._triggerPrepare(siReq);
				gateway.call(request.si, request.method, request.data, siReq);
			});
			
			socket.on('watch', function(request) {
				gateway._watch(socket, request);
			});
			
			socket.on('unwatch', function(requests) {
				gateway._unwatch(socket, requests);
			});
			
			socket.on('disconnect', function() {
				gateway._unwatchAll(socket);
			});
		});
		
		self._server.listen(port);
	}
	
	self.useScript = function(pathFromRoot, type) {
		self._router.includeClientScript(pathFromRoot, type);
	}
	
	self.useStyle = function(pathFromRoot, type, rel) {
		self._router.includeClientStyle(pathFromRoot, type, rel);
	}
	
	self._triggerPrepare = function(siRequest) {
		var i;
		var len = self._prepareCallbacks.length;
		for(i=0; i<len; i++) {
			self._prepareCallbacks[i](siRequest);
		}
	}
	
	self.initialize = function(callback) {
		self._router.initialize(callback);
	}
	
	self.uninitialize = function(callback) {
		self._router.uninitialize(callback);
	}
	
	self.prepare = function(callback) {
		self._prepareCallbacks.push(callback);
	}
	
	self.unprepare = function(callback) {
		var newList = [];
		var len = self._prepareCallbacks.length;
		var i;
		for(i=0; i<len; i++) {
			if(self._prepareCallbacks[i] != callback) {
				newList.push(self._prepareCallbacks[i]);
			}
		}
		self._prepareCallbacks = newList;
	}
})();

var NS = function(namespace) {
	var self = this;
	self._namespace = namespace;
	
	self.broadcast = function(event, data) {
		if(!self._namespace || !event) {
			throw "Exception: One or more required parameters were undefined";
		}
		
		var eventObject = {namespace: self._namespace, event: event, data: data};
		var i;
		var watchers = gateway.getWatchers(self._namespace, event);
		
		for(i in watchers) {
			watchers[i].emit('event', eventObject);
		}
	}
}

var ServerInterfaceRequest = function(socket, request) {
	var self = this;
	self._open = true;
	self._socket = socket;
	self._request = request;
	self._mainNamespace = new NS('__main');
	self._namespaces = {'__main': self._mainNamespace};
	
	self._emitReturn = function(data) {
		if(self._open) {
			self._socket.emit('return', data);
		} else {
			throw "Exception: The current ServerInterfaceRequest has already been closed";
		}
		if(data.close) {
			self._open = false;
		}
	}
	
	self.send = function(data) {
		self._emitReturn({cid: self._request.cid, value: data});
	}
	
	self.respond = function(data) {
		self._emitReturn({cid: self._request.cid, value: data, close: 1});
	}
	
	self.error = function(data) {
		self._emitReturn({cid: self._request.cid, value: data, error: 1});
	}
	
	self.collapse = function(data) {
		self._emitReturn({cid: self._request.cid, value: data, error: 1, close: 1});
	}
	
	self.close = function() {
		self._emitReturn({cid: self._request.cid, close: 1, noValue: 1});
	}
	
	self.emit = function() {
		if(arguments.length < 2) {
			throw "Exception: One or more required parameters were undefined";
		}
		
		if(arguments.length > 2) {
			var namespace = arguments[0];
			var event = arguments[1];
			var data = arguments[2];
		} else {
			var namespace = '';
			var event = arguments[0];
			var data = arguments[1];
		}
		
		var eventObject = {namespace: namespace, event: event, data: data};
		self._socket.emit('event', eventObject);
	}
	
	self.set = function() {
		self._socket.set.apply(self._socket, arguments);
	}
	
	self.get = function() {
		self._socket.get.apply(self._socket, arguments);
	}
	
	self.ns = function(namespace) {
		if(!self._namespaces[namespace]) {
			self._namespaces[namespace] = new NS(namespace);
		}
		return self._namespaces[namespace];
	}
	
	self.broadcast = function() {
		self._mainNamespace.broadcast.apply(null, arguments);
	}
	
	self.getServerInterface = function() {
		return self._request.si;
	}
	
	self.getMethod = function() {
		return self._request.method;
	}
	
	self.getData = function() {
		return self._request.data;
	}
}

module.exports = nCombo;