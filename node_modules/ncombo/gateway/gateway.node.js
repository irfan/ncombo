var path = require('path'),
	fs = require('fs'),
	ndata = require('ndata'),
	async = require('async'),
	io = require('socket.io-client'),
	wrench = require('wrench'),
	EventEmitter = require('events').EventEmitter;

var Gateway = function() {
	var self = this;
	self._siDir = null;
	self._dataClient = null;
	self._serverInterfaces = {};
	self._privateExtension = /$a/;
	self._allowedMap = {'*': true};
	self._releaseMode = false;
	
	self.init = function(serverInterfaceDir, dataClient, privateExtensionRegex) {
		self._siDir = path.normalize(serverInterfaceDir);
		self._dataClient = dataClient;
		
		if(privateExtensionRegex) {
			self._privateExtension = privateExtensionRegex;
		}
		
		var files = wrench.readdirSyncRecursive(self._siDir);
		var serverInterfaceFiles = fs.readdirSync(self._siDir);
		var i, file, siName, match;
		var privateExt = new RegExp('(.*)(' + self._privateExtension.source + ')');
		var publicExt = /(.*)[.]js$/;
		var backslashes = /\\/g;
		for(i in files) {
			file = files[i];
			match = file.match(privateExt);
			if(match) {
				siName = match[1].replace(backslashes, '/');
				if(!self._serverInterfaces.hasOwnProperty(siName)) {
					self._serverInterfaces[siName] = require(self._siDir + file);
				}
			} else {
				match = file.match(publicExt);
				if(match) {
					siName = match[1].replace(backslashes, '/');
					if(!self._serverInterfaces.hasOwnProperty(siName)) {
						self._serverInterfaces[siName] = require(self._siDir + file);
					}
				}
			}
		}
	}
	
	self.setReleaseMode = function(bool) {
		self._releaseMode = bool;
	}
	
	self.exec = function(siReq) {
		var serverInterface = siReq.si;
		var method = siReq.method;
		self._serverInterfaces[serverInterface][method](siReq);
	}
	
	self._getSessionEventKey = function(sessionID, key) {
		if(key) {
			return '__sessionevent.' + sessionID + '.' + key;
		} else {
			return '__sessionevent.' + sessionID;
		}
	}
	
	self.watch = function(siReq) {
		var ns = siReq.ns;
		var event = siReq.event;
		var id = siReq.session.id;
		
		var eventKey = ns + '.' + event;
		var sessionEventString = self._getSessionEventKey(id, eventKey);
		
		var handler = function(value) {
			siReq.session.ns(ns).emit(event, value);
		}
		
		self._dataClient.watchExclusive(sessionEventString, handler, function(err) {
			siReq.end(err);
		});
	}
	
	self.unwatch = function(siReq) {
		var socket = siReq.socket;
		var requests = siReq.requests;
		var id = siReq.session.id;
		var i, req, ns, event, eventKey, sessionEventString;
		var events = [];
		
		var successCount = 0;
		var failEmitted = false;
		
		if(requests.length > 0) {
			for(i in requests) {
				req = requests[i];
				ns = req.ns;
				event = req.event;
				events.push(event);
				
				eventKey = ns + '.' + event;
				sessionEventString = self._getSessionEventKey(id, eventKey);
				
				self._dataClient.unwatch(sessionEventString, null, function(err) {
					siReq.end(err);
				});
			}
		} else {
			siReq.end();
		}
	}
	
	self.unwatchAll = function(session, ackCallback) {
		var sessionEventString = self._getSessionEventKey(session.id);
		self._dataClient.unwatch(sessionEventString, null, ackCallback);
	}
}

Gateway.prototype.__proto__ = EventEmitter.prototype;

module.exports = new Gateway();
